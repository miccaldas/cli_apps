content
"(['pyutils/line_profiler', 'Name already in use', 'line_profiler and kernprof', 'not', 't_end'], ['\n        Line-by-line profiling for Python\n      ', '\n        Use Git or checkout with SVN using the web URL.\n    ', '\n      Work fast with our official CLI.\n      ', '.\n    ', '\n                Please\n                ', '\n                to use Codespaces.\n              ', '\n    If nothing happens, ', ' and try again.\n  ', '\n    If nothing happens, ', ' and try again.\n  ', '\n    If nothing happens, ', ' and try again.\n  ', 'Your codespace will open once ready.', 'There was a problem preparing your codespace, please try again.', ' ', ' ', ' ', ' ', 'NOTICE: This is the official line_profiler repository. The most recent\nversion of ', ' on pypi\npoints to this repo. The original\n', ' package by\n', ' is currently unmaintained. This fork\nseeks to simply maintain the original code so it continues to work in new\nversions of Python.', ""line_profiler is a module for doing line-by-line profiling of functions.\nkernprof is a convenient script for running either line_profiler or the Python\nstandard library's cProfile or profile modules, depending on what is available."", 'They are available under a ', '.', 'Contents', 'To profile a python script:', 'Releases of line_profiler can be installed using pip:', 'Installation while ensuring a compatible IPython version can also be installed using pip:', 'To check out the development sources, you can use ', ':', 'You may also download source tarballs of any snapshot from that URL.', 'Source releases will require a C compiler in order to build line_profiler.\nIn addition, git checkouts will also require Cython. Source releases\non PyPI should contain the pregenerated C sources, so Cython should not be\nrequired in that case.', 'kernprof is a single-file pure Python script and does not require\na compiler.  If you wish to use it to run cProfile and not line-by-line\nprofiling, you may copy it to a directory on your PATH manually and avoid\ntrying to build any C extensions.', 'As of 2021-06-04 Linux (x86_64 and i686), OSX (10_9_x86_64), and Win32 (win32,\nand amd64) binaries are available on pypi.', ""Alternatively on windows you might consider using Christoph Gohlke's\nunofficial line-profiler\n"", '.', 'The last version of line profiler to support Python 2.7 was 3.1.0 and the last\nversion to support Python 3.5 was 3.3.1.', ""The current profiling tools supported in Python only time\nfunction calls. This is a good first step for locating hotspots in one's program\nand is frequently all one needs to do to optimize the program. However,\nsometimes the cause of the hotspot is actually a single line in the function,\nand that line may not be obvious from just reading the source code. These cases\nare particularly frequent in scientific computing. Functions tend to be larger\n(sometimes because of legitimate algorithmic complexity, sometimes because the\nprogrammer is still trying to write FORTRAN code), and a single statement\nwithout function calls can trigger lots of computation when using libraries like\nnumpy. cProfile only times explicit function calls, not special methods called\nbecause of syntax. Consequently, a relatively slow numpy operation on large\narrays like this,"", 'is a hotspot that never gets broken out by cProfile because there is no explicit\nfunction call in that statement.', 'LineProfiler can be given functions to profile, and it will time the execution\nof each individual line inside those functions. In a typical workflow, one only\ncares about line timings of a few functions because wading through the results\nof timing every single line of code would be overwhelming. However, LineProfiler\ndoes need to be explicitly told what functions to profile. The easiest way to\nget started is to use the kernprof script.', 'kernprof will create an instance of LineProfiler and insert it into the\n__builtins__ namespace with the name profile. It has been written to be\nused as a decorator, so in your script, you decorate the functions you want\nto profile with @profile.', 'The default behavior of kernprof is to put the results into a binary file\nscript_to_profile.py.lprof . You can tell kernprof to immediately view the\nformatted results at the terminal with the [-v/--view] option. Otherwise, you\ncan view the results later like so:', 'For example, here are the results of profiling a single function from\na decorated version of the pystone.py benchmark (the first two lines are output\nfrom pystone.py, not kernprof):', 'The source code of the function is printed with the timing information for each\nline. There are six columns of information.', 'If you are using IPython, there is an implementation of an %lprun magic command\nwhich will let you specify functions to profile and a statement to execute. It\nwill also add its LineProfiler instance into the __builtins__, but typically,\nyou would not use it like that.', ""For IPython 0.11+, you can install it by editing the IPython configuration file\n~/.ipython/profile_default/ipython_config.py to add the 'line_profiler'\nitem to the extensions list:"", 'To get usage help for %lprun, use the standard IPython help mechanism:', 'These two methods are expected to be the most frequent user-level ways of using\nLineProfiler and will usually be the easiest. However, if you are building other\ntools with LineProfiler, you will need to use the API. There are two ways to\ninform LineProfiler of functions to profile: you can pass them as arguments to\nthe constructor or use the add_function(f) method after instantiation.', 'LineProfiler has the same run(), runctx(), and runcall() methods as\ncProfile.Profile as well as enable() and disable(). It should be noted,\nthough, that enable() and disable() are not entirely safe when nested.\nNesting is common when using LineProfiler as a decorator. In order to support\nnesting, use enable_by_count() and disable_by_count(). These functions will\nincrement and decrement a counter and only actually enable or disable the\nprofiler when the count transitions from or to 0.', 'After profiling, the dump_stats(filename) method will pickle the results out\nto the given file. print_stats([stream]) will print the formatted results to\nsys.stdout or whatever stream you specify. get_stats() will return LineStats\nobject, which just holds two attributes: a dictionary containing the results and\nthe timer unit.', 'kernprof also works with cProfile, its third-party incarnation lsprof, or the\npure-Python profile module depending on what is available. It has a few main\nfeatures:', 'The results of profile script_to_profile.py will be written to\nscript_to_profile.py.prof by default. It will be a typical marshalled file that\ncan be read with pstats.Stats(). They may be interactively viewed with the\ncommand:', 'Such files may also be viewed with graphical tools. A list of 3rd party tools\nbuilt on ', ' or ', ' are as follows:', 'Why the name ""kernprof""?', ""I didn't manage to come up with a meaningful name, so I named it after\nmyself."", 'Why not use hotshot instead of line_profile?', 'hotshot can do line-by-line timings, too. However, it is deprecated and may\ndisappear from the standard library. Also, it can take a long time to\nprocess the results while I want quick turnaround in my workflows. hotshot\npays this processing time in order to make itself minimally intrusive to the\ncode it is profiling. Code that does network operations, for example, may\neven go down different code paths if profiling slows down execution too\nmuch. For my use cases, and I think those of many other people, their\nline-by-line profiling is not affected much by this concern.', 'Why not allow using hotshot from kernprof.py?', ""I don't use hotshot, myself. I will accept contributions in this vein,\nthough."", ""The line-by-line timings don't add up when one profiled function calls\nanother. What's up with that?"", ""Let's say you have function F() calling function G(), and you are using\nLineProfiler on both. The total time reported for G() is less than the time\nreported on the line in F() that calls G(). The reason is that I'm being\nreasonably clever (and possibly too clever) in recording the times.\nBasically, I try to prevent recording the time spent inside LineProfiler\ndoing all of the bookkeeping for each line. Each time Python's tracing\nfacility issues a line event (which happens just before a line actually gets\nexecuted), LineProfiler will find two timestamps, one at the beginning\nbefore it does anything (t_begin) and one as close to the end as possible\n(t_end). Almost all of the overhead of LineProfiler's data structures\nhappens in between these two times."", ""When a line event comes in, LineProfiler finds the function it belongs to.\nIf it's the first line in the function, we record the line number and\n"", "" associated with the function. The next time we see a line event\nbelonging to that function, we take t_begin of the new event and subtract\nthe old t_end from it to find the amount of time spent in the old line. Then\nwe record the new t_end as the active line for this function. This way, we\nare removing most of LineProfiler's overhead from the results. Well almost.\nWhen one profiled function F calls another profiled function G, the line in\nF that calls G basically records the total time spent executing the line,\nwhich includes the time spent inside the profiler while inside G."", 'The first time this question was asked, the questioner had the G() function\ncall as part of a larger expression, and he wanted to try to estimate how\nmuch time was being spent in the function as opposed to the rest of the\nexpression. My response was that, even if I could remove the effect, it\nmight still be misleading. G() might be called elsewhere, not just from the\nrelevant line in F(). The workaround would be to modify the code to split it\nup into two lines, one which just assigns the result of G() to a temporary\nvariable and the other with the rest of the expression.', 'I am open to suggestions on how to make this more robust. Or simple\nadmonitions against trying to be clever.', 'Why do my list comprehensions have so many hits when I use the LineProfiler?', 'LineProfiler records the line with the list comprehension once for each\niteration of the list comprehension.', 'Why is kernprof distributed with line_profiler? It works with just cProfile,\nright?', ""Partly because kernprof.py is essential to using line_profiler effectively,\nbut mostly because I'm lazy and don't want to maintain the overhead of two\nprojects for modules as small as these. However, kernprof.py is\na standalone, pure Python script that can be used to do function profiling\nwith just the Python standard library. You may grab it and install it by\nitself without line_profiler."", 'Do I need a C compiler to build line_profiler? kernprof.py?', 'You do need a C compiler for line_profiler. kernprof.py is a pure Python\nscript and can be installed separately, though.', 'Do I need Cython to build line_profiler?', 'You should not have to if you are building from a released source tarball.\nIt should contain the generated C sources already. If you are running into\nproblems, that may be a bug; let me know. If you are building from\na git checkout or snapshot, you will need Cython to generate the\nC sources.', 'As of version ', ' manylinux wheels containing the binaries are\navailable on pypi. Work is still needed to publish osx and win32 wheels.\n(PRs for this would be helpful!)', 'What version of Python do I need?', 'Both line_profiler and kernprof have been tested with Python 3.5-3.9.\nOlder versions of line_profiler support older versions of Python.', 'cProfile uses a neat ""rotating trees"" data structure to minimize the overhead of\nlooking up and recording entries. LineProfiler uses Python dictionaries and\nextension objects thanks to Cython. This mostly started out as a prototype that\nI wanted to play with as quickly as possible, so I passed on stealing the\nrotating trees for now. As usual, I got it working, and it seems to have\nacceptable performance, so I am much less motivated to use a different strategy\nnow. Maybe later. Contributions accepted!', 'Bugs and pull requested can be submitted on ', '.', 'See ', '.', '\n      Line-by-line profiling for Python\n    ', '\n      ', '\n      ', '\n  ', '\n  ', '\n  ', '\n  ', '\n  ', '\n  ', '\n  ', '\n  ', 'Explore', '\n  ', '\n  ', '\n  ', '\n  ', '\n', '\n      ', '\n      ', 'For', '\n  ', '\n  ', '\n  ', '\n  ', 'By Solution', '\n  ', '\n  ', '\n  ', 'Case Studies', '\n  ', '\n  ', '\n', '\n      ', '\n      ', '\n  ', '\n  ', 'Repositories', '\n  ', '\n  ', '\n  ', '\n', '\n    ', '\n', '\n  ', '\n', '\n    ', '\n  ', '\n  ', '\n', '\n  ', '\n', '\n  ', '\n', '\n            ', '  ', '\n          ', '\n  ', '\n        ', '\n  ', '\n  ', '\n  ', '\n  ', '\n  ', '\n  ', '\n  ', '\n  ', '\n  ', '\n                ', '              ', '\n                ', '              ', '\n                ', '              ', '\n                ', '              ', '\n                ', '              ', '\n                ', '              ', '\n                ', '              ', '\n                ', '              ', '\n  ', '\n  ', '\n  ', '\n\n', '\n\n', '\n\n', '\n  ', '\n  ', '\n            ', '\n          ', 'Install line_profiler: ', '.', 'Decorate function(s) you want to profile with @profile. The decorator will be made automatically available on run.', 'Run ', '.', 'Line #: The line number in the file.', 'Hits: The number of times that line was executed.', 'Time: The total amount of time spent executing the line in the timer\'s\nunits. In the header information before the tables, you will see a line\n""Timer unit:"" giving the conversion factor to seconds. It may be different\non different systems.', ""Per Hit: The average amount of time spent executing the line once in the\ntimer's units."", '% Time: The percentage of time spent on that line relative to the total\namount of recorded time spent in the function.', 'Line Contents: The actual source code. Note that this is always read from\ndisk when the formatted results are viewed, ', ' when the code was\nexecuted. If you have edited the file in the meantime, the lines will not\nmatch up, and the formatter may not even be able to locate the function\nfor display.', 'Encapsulation of profiling concerns. You do not have to modify your script\nin order to initiate profiling and save the results. Unless if you want to\nuse the advanced __builtins__ features, of course.', 'Robust script execution. Many scripts require things like __name__,\n__file__, and sys.path to be set relative to it. A naive approach at\nencapsulation would just use execfile(), but many scripts which rely on\nthat information will fail. kernprof will set those variables correctly\nbefore executing the script.', 'Easy executable location. If you are profiling an application installed on\nyour PATH, you can just give the name of the executable. If kernprof does\nnot find the given script in the current directory, it will search your\nPATH for it.', 'Inserting the profiler into __builtins__. Sometimes, you just want to\nprofile a small part of your code. With the [-b/--builtin] argument, the\nProfiler will be instantiated and inserted into your __builtins__ with the\nname ""profile"". Like LineProfiler, it may be used as a decorator, or\nenabled/disabled with enable_by_count() and disable_by_count(), or\neven as a context manager with the ""with profile:"" statement.', 'Pre-profiling setup. With the [-s/--setup] option, you can provide\na script which will be executed without profiling before executing the\nmain script. This is typically useful for cases where imports of large\nlibraries like wxPython or VTK are interfering with your results. If you\ncan modify your source code, the __builtins__ approach may be\neasier.', ': converts profiling data to a format\nthat can be visualized using ', ' (linux only), ', '\n(windows only, unmaintained), or  ', '.', ': Qt GUI for line_profiler.', ': A web viewer for Python profiling data.', ': A fork of ', ', ported to Python 3.', ': A PyCharm plugin for line_profiler.', ': A plugin to run line_profiler from within the Spyder IDE.', ': A render web report for ', '.', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n      ', '\n    ', '\n      ', '\n    ', '\n      ', '\n    ', '\n      ', '\n    ', '\n      ', '\n    ', '\n      ', '\n    ', '\n      ', '\n    ', '\n      ', '\n    ', '\n      ', '\n    ', '\n      ', '\n    ', '\n      ', '\n    ', '\n        ', '\n    ', '\n        ', '\n    ', '\n        ', '\n    ', '\n        ', '\n    ', '\n        ', '\n    '])"
