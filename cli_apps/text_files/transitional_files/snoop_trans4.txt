description snoop is a powerful set of Python debugging tools. It's primarily meant to be a  version of . It also includes its own version of  and some other nifty stuff."You're trying to figure out why your Python code isn't doing what you think it should be doing. You'd love to use a full-fledged debugger with breakpoints and watches, but you can't be bothered to set one up right now.""You want to know which lines are running and which aren't, and what the values of the local variables are."Most people would use " lines, in strategic locations, some of them showing the values of variables."" lets you do the same, except instead of carefully crafting the right "" lines, you just add one decorator line to the function you're interested in. You'll get a play-by-play log of your function, including which lines ran and when, and exactly when local variables were changed."Installation is as simple as ."We're writing a function that converts a number to binary, by returning a list of bits. Let's snoop on it by adding the " decorator:Note how easy it is: Just  and ". If you don't like the magical import, " and " still work too. Or if you don't want to import in your project at all, just call " somewhere once.The output to stderr looks like this:Let's try a more complex example. We're writing a memoizing decorator: it stores function arguments and return values in a cache to avoid recomputation:Here we specify  to mean we should also step one level down into inner function calls. We then call the function twice to see the caching in action. Here's the output:At a glance we can see that in the first call the cache lookup failed with a  so the original " function was called, while in the second call the previously cached result was returned immediately.""If you don't want to trace an entire function, you can wrap the relevant part in a " block:which outputs something like:This will output lines like:See  for more advanced usage of this argument.See " to show additional information about any value (local variable, watched expression, or exploded item) automatically."While  is meant to save you from writing " calls, sometimes that's still exactly the kind of thing you need. " aims to be the best possible version of this. It can be used alone or in combination with . will output ", i.e. it will show the source code of its argument(s) so you know what's being printed, and format the value with " so that you can easily see the layout of complicated data structures. If  or  is installed their  will be used instead of ." will return its argument directly so you can easily insert it in code without rearranging. If given multiple arguments, it will return them as a tuple, so you can replace " with  to leave the behaviour of the code intact.Here's an example:Output:If you've already got  you can also use ". But ideally, you would use " to avoid importing at all.There are a few situations where " can't find the source code of its arguments, in which case it will show a placeholder instead:""Under the hood, " uses the library  to locate the AST node of the function call - check it out if you'd like to write some cool utilities of your own. is inspired by " and offers the same basic API for printing, but " integrates seamlessly with  and offers ", which is unique."'' stands for 'pretty-print' and . It's also very easy and quick to type.If you have " and you want to see what happens inside that expression and not just the final value, replace it wth "". This will log every intermediate subexpression, in the correct order, with no additional side effects, and return the final value. Repeating the previous example:"Output:(the values of literals and builtins are left out because they're trivial)"If an exception is raised, it'll show which subexpression is responsible, which looks something like this:""If you like this, you'll probably love ".The  decorator lets you combine  with the powerful debugger . The code:is roughly equivalent to:To reduce the dependencies of ", you'll need to install " separately: .The only big disadvantage of " is that it significantly reduces performance, so avoid it for functions with many loop iterations. Otherwise you can basically always use it instead of "". Then if the logs don't have the information you need you can open up the birdseye UI to see more detail, without needing to edit or rerun your code. Great for when you're feeling lazy and unsure which tool is best." passes its arguments to ", so e.g. " works.('' is so named because it's a combination of the decorator names '' and '')"To make regularly debugging your project more convenient, run this code early on:"Then ", "", and " will be available in every file without needing to import them.You can choose different names by passing keyword arguments ", e.g:"will let you decorate functions with ."If you dislike this feature and would prefer to just import normally, but you want to use "" for other configuration, pass "."As an alternative, in Python 3.7+ you can use the new " function in place of  if you set the environment variable .If you would like to leave " and other functions in your codebase but disable their effects, pass "". For example, if you're using Django, put " in " to automatically disable it in production. When disabled, performance impact is minimised and there is no output anywhere."You can also dynamically re-enable the functions at any point by calling " again, e.g. in a special view or signal handler." has several keyword arguments for controlling the output of  and :If you're familiar with  and want to use ", there are a few things you should be aware of that you have to do differently:"If you're not sure if it's worth using  instead of ", ".snoop comes with an IPython extension that you can use in shells or notebooks.First you need to ", using either " in a notebook cell or by adding  to the list " in your IPython configuration file, e.g. ".Then use the cell magic  at the top of a notebook cell to trace that cell: has another parameter called ". You can pass it a list of functions to automatically show extra information about any value: local variables, watched expressions, and exploded items. For example, suppose you wanted to see the type of every variable. You could define a function like this:"You would then write . The result is output like this:The functions you write should accept two arguments  and " - typically these will be the name of a variable and its actual value. They should return a pair representing the 'source' of the returned information (used only for display, it doesn't have to be valid Python) and the actual information. If you don't want to display anything for this particular value, return ". Any exceptions raised are caught and silenced.Two such functions are already enabled by default: one which shows either the  or the " property (used by numpy, pandas, tensorflow, etc) of values, and one which shows the " property." is added to these two default functions so you don't have to specify them again. If you don't want to include them, use " instead to specify the exact list. The original functions can be found here: will automatically guess how to expand the expression passed to it based on its class. You can be more specific by using one of the following classes:Exclude specific keys/attributes/indices with the " parameter, e.g. ".Add a slice after " to only see the values within that slice, e.g. ".(See also )Values are rendered using the " library to improve performance and avoid flooding the console. It has a specially defined repr function for most common classes, including from third party libraries. If a class is missing, please open an issue there. You can also register your own repr for the class. Here's an example:"Read more ."You can also increase the verbosity of individual classes (see the documentation), e.g:"If you need more control than the global " function, e.g. if you want to write to several different files in one process, you can create a "" object, e.g: ". Then ", " and  will use that configuration rather than the global one.The arguments are the same as the arguments of  relating to output configuration and .I'd love to hear from users! Obviously " if you have one, but also check out ". There's still a lot more work that can be done and I really want people's opinions so that I can do it right.You can also  what you like or hate about . Just knowing it's being used is helpful. are always welcome!"Please, write tests and run them with ".Tox installs all dependencies automatically. You only need to install Tox itself:If you want to run tests against all target Python versions use " to install them. Otherwise, you can runonly the ones you have already installed on your machine:"Or just install project in developer mode with test dependencies:And run tests:description snoop is a powerful set of Python debugging tools. It's primarily meant to be a  version of . It also includes its own version of  and some other nifty stuff."You're trying to figure out why your Python code isn't doing what you think it should be doing. You'd love to use a full-fledged debugger with breakpoints and watches, but you can't be bothered to set one up right now.""You want to know which lines are running and which aren't, and what the values of the local variables are."Most people would use " lines, in strategic locations, some of them showing the values of variables."" lets you do the same, except instead of carefully crafting the right "" lines, you just add one decorator line to the function you're interested in. You'll get a play-by-play log of your function, including which lines ran and when, and exactly when local variables were changed."Installation is as simple as ."We're writing a function that converts a number to binary, by returning a list of bits. Let's snoop on it by adding the " decorator:Note how easy it is: Just  and ". If you don't like the magical import, " and " still work too. Or if you don't want to import in your project at all, just call " somewhere once.The output to stderr looks like this:Let's try a more complex example. We're writing a memoizing decorator: it stores function arguments and return values in a cache to avoid recomputation:Here we specify  to mean we should also step one level down into inner function calls. We then call the function twice to see the caching in action. Here's the output:At a glance we can see that in the first call the cache lookup failed with a  so the original " function was called, while in the second call the previously cached result was returned immediately.""If you don't want to trace an entire function, you can wrap the relevant part in a " block:which outputs something like:This will output lines like:See  for more advanced usage of this argument.See " to show additional information about any value (local variable, watched expression, or exploded item) automatically."While  is meant to save you from writing " calls, sometimes that's still exactly the kind of thing you need. " aims to be the best possible version of this. It can be used alone or in combination with . will output ", i.e. it will show the source code of its argument(s) so you know what's being printed, and format the value with " so that you can easily see the layout of complicated data structures. If  or  is installed their  will be used instead of ." will return its argument directly so you can easily insert it in code without rearranging. If given multiple arguments, it will return them as a tuple, so you can replace " with  to leave the behaviour of the code intact.Here's an example:Output:If you've already got  you can also use ". But ideally, you would use " to avoid importing at all.There are a few situations where " can't find the source code of its arguments, in which case it will show a placeholder instead:""Under the hood, " uses the library  to locate the AST node of the function call - check it out if you'd like to write some cool utilities of your own. is inspired by " and offers the same basic API for printing, but " integrates seamlessly with  and offers ", which is unique."'' stands for 'pretty-print' and . It's also very easy and quick to type.If you have " and you want to see what happens inside that expression and not just the final value, replace it wth "". This will log every intermediate subexpression, in the correct order, with no additional side effects, and return the final value. Repeating the previous example:"Output:(the values of literals and builtins are left out because they're trivial)"If an exception is raised, it'll show which subexpression is responsible, which looks something like this:""If you like this, you'll probably love ".The  decorator lets you combine  with the powerful debugger . The code:is roughly equivalent to:To reduce the dependencies of ", you'll need to install " separately: .The only big disadvantage of " is that it significantly reduces performance, so avoid it for functions with many loop iterations. Otherwise you can basically always use it instead of "". Then if the logs don't have the information you need you can open up the birdseye UI to see more detail, without needing to edit or rerun your code. Great for when you're feeling lazy and unsure which tool is best." passes its arguments to ", so e.g. " works.('' is so named because it's a combination of the decorator names '' and '')"To make regularly debugging your project more convenient, run this code early on:"Then ", "", and " will be available in every file without needing to import them.You can choose different names by passing keyword arguments ", e.g:"will let you decorate functions with ."If you dislike this feature and would prefer to just import normally, but you want to use "" for other configuration, pass "."As an alternative, in Python 3.7+ you can use the new " function in place of  if you set the environment variable .If you would like to leave " and other functions in your codebase but disable their effects, pass "". For example, if you're using Django, put " in " to automatically disable it in production. When disabled, performance impact is minimised and there is no output anywhere."You can also dynamically re-enable the functions at any point by calling " again, e.g. in a special view or signal handler." has several keyword arguments for controlling the output of  and :If you're familiar with  and want to use ", there are a few things you should be aware of that you have to do differently:"If you're not sure if it's worth using  instead of ", ".snoop comes with an IPython extension that you can use in shells or notebooks.First you need to ", using either " in a notebook cell or by adding  to the list " in your IPython configuration file, e.g. ".Then use the cell magic  at the top of a notebook cell to trace that cell: has another parameter called ". You can pass it a list of functions to automatically show extra information about any value: local variables, watched expressions, and exploded items. For example, suppose you wanted to see the type of every variable. You could define a function like this:"You would then write . The result is output like this:The functions you write should accept two arguments  and " - typically these will be the name of a variable and its actual value. They should return a pair representing the 'source' of the returned information (used only for display, it doesn't have to be valid Python) and the actual information. If you don't want to display anything for this particular value, return ". Any exceptions raised are caught and silenced.Two such functions are already enabled by default: one which shows either the  or the " property (used by numpy, pandas, tensorflow, etc) of values, and one which shows the " property." is added to these two default functions so you don't have to specify them again. If you don't want to include them, use " instead to specify the exact list. The original functions can be found here: will automatically guess how to expand the expression passed to it based on its class. You can be more specific by using one of the following classes:Exclude specific keys/attributes/indices with the " parameter, e.g. ".Add a slice after " to only see the values within that slice, e.g. ".(See also )Values are rendered using the " library to improve performance and avoid flooding the console. It has a specially defined repr function for most common classes, including from third party libraries. If a class is missing, please open an issue there. You can also register your own repr for the class. Here's an example:"Read more ."You can also increase the verbosity of individual classes (see the documentation), e.g:"If you need more control than the global " function, e.g. if you want to write to several different files in one process, you can create a "" object, e.g: ". Then ", " and  will use that configuration rather than the global one.The arguments are the same as the arguments of  relating to output configuration and .I'd love to hear from users! Obviously " if you have one, but also check out ". There's still a lot more work that can be done and I really want people's opinions so that I can do it right.You can also  what you like or hate about . Just knowing it's being used is helpful. are always welcome!"Please, write tests and run them with ".Tox installs all dependencies automatically. You only need to install Tox itself:If you want to run tests against all target Python versions use " to install them. Otherwise, you can runonly the ones you have already installed on your machine:"Or just install project in developer mode with test dependencies:And run tests:description snoop is a powerful set of Python debugging tools. It's primarily meant to be a  version of . It also includes its own version of  and some other nifty stuff."You're trying to figure out why your Python code isn't doing what you think it should be doing. You'd love to use a full-fledged debugger with breakpoints and watches, but you can't be bothered to set one up right now.""You want to know which lines are running and which aren't, and what the values of the local variables are."Most people would use " lines, in strategic locations, some of them showing the values of variables."" lets you do the same, except instead of carefully crafting the right "" lines, you just add one decorator line to the function you're interested in. You'll get a play-by-play log of your function, including which lines ran and when, and exactly when local variables were changed."Installation is as simple as ."We're writing a function that converts a number to binary, by returning a list of bits. Let's snoop on it by adding the " decorator:Note how easy it is: Just  and ". If you don't like the magical import, " and " still work too. Or if you don't want to import in your project at all, just call " somewhere once.The output to stderr looks like this:Let's try a more complex example. We're writing a memoizing decorator: it stores function arguments and return values in a cache to avoid recomputation:Here we specify  to mean we should also step one level down into inner function calls. We then call the function twice to see the caching in action. Here's the output:At a glance we can see that in the first call the cache lookup failed with a  so the original " function was called, while in the second call the previously cached result was returned immediately.""If you don't want to trace an entire function, you can wrap the relevant part in a " block:which outputs something like:This will output lines like:See  for more advanced usage of this argument.See " to show additional information about any value (local variable, watched expression, or exploded item) automatically."While  is meant to save you from writing " calls, sometimes that's still exactly the kind of thing you need. " aims to be the best possible version of this. It can be used alone or in combination with . will output ", i.e. it will show the source code of its argument(s) so you know what's being printed, and format the value with " so that you can easily see the layout of complicated data structures. If  or  is installed their  will be used instead of ." will return its argument directly so you can easily insert it in code without rearranging. If given multiple arguments, it will return them as a tuple, so you can replace " with  to leave the behaviour of the code intact.Here's an example:Output:If you've already got  you can also use ". But ideally, you would use " to avoid importing at all.There are a few situations where " can't find the source code of its arguments, in which case it will show a placeholder instead:""Under the hood, " uses the library  to locate the AST node of the function call - check it out if you'd like to write some cool utilities of your own. is inspired by " and offers the same basic API for printing, but " integrates seamlessly with  and offers ", which is unique."'' stands for 'pretty-print' and . It's also very easy and quick to type.If you have " and you want to see what happens inside that expression and not just the final value, replace it wth "". This will log every intermediate subexpression, in the correct order, with no additional side effects, and return the final value. Repeating the previous example:"Output:(the values of literals and builtins are left out because they're trivial)"If an exception is raised, it'll show which subexpression is responsible, which looks something like this:""If you like this, you'll probably love ".The  decorator lets you combine  with the powerful debugger . The code:is roughly equivalent to:To reduce the dependencies of ", you'll need to install " separately: .The only big disadvantage of " is that it significantly reduces performance, so avoid it for functions with many loop iterations. Otherwise you can basically always use it instead of "". Then if the logs don't have the information you need you can open up the birdseye UI to see more detail, without needing to edit or rerun your code. Great for when you're feeling lazy and unsure which tool is best." passes its arguments to ", so e.g. " works.('' is so named because it's a combination of the decorator names '' and '')"To make regularly debugging your project more convenient, run this code early on:"Then ", "", and " will be available in every file without needing to import them.You can choose different names by passing keyword arguments ", e.g:"will let you decorate functions with ."If you dislike this feature and would prefer to just import normally, but you want to use "" for other configuration, pass "."As an alternative, in Python 3.7+ you can use the new " function in place of  if you set the environment variable .If you would like to leave " and other functions in your codebase but disable their effects, pass "". For example, if you're using Django, put " in " to automatically disable it in production. When disabled, performance impact is minimised and there is no output anywhere."You can also dynamically re-enable the functions at any point by calling " again, e.g. in a special view or signal handler." has several keyword arguments for controlling the output of  and :If you're familiar with  and want to use ", there are a few things you should be aware of that you have to do differently:"If you're not sure if it's worth using  instead of ", ".snoop comes with an IPython extension that you can use in shells or notebooks.First you need to ", using either " in a notebook cell or by adding  to the list " in your IPython configuration file, e.g. ".Then use the cell magic  at the top of a notebook cell to trace that cell: has another parameter called ". You can pass it a list of functions to automatically show extra information about any value: local variables, watched expressions, and exploded items. For example, suppose you wanted to see the type of every variable. You could define a function like this:"You would then write . The result is output like this:The functions you write should accept two arguments  and " - typically these will be the name of a variable and its actual value. They should return a pair representing the 'source' of the returned information (used only for display, it doesn't have to be valid Python) and the actual information. If you don't want to display anything for this particular value, return ". Any exceptions raised are caught and silenced.Two such functions are already enabled by default: one which shows either the  or the " property (used by numpy, pandas, tensorflow, etc) of values, and one which shows the " property." is added to these two default functions so you don't have to specify them again. If you don't want to include them, use " instead to specify the exact list. The original functions can be found here: will automatically guess how to expand the expression passed to it based on its class. You can be more specific by using one of the following classes:Exclude specific keys/attributes/indices with the " parameter, e.g. ".Add a slice after " to only see the values within that slice, e.g. ".(See also )Values are rendered using the " library to improve performance and avoid flooding the console. It has a specially defined repr function for most common classes, including from third party libraries. If a class is missing, please open an issue there. You can also register your own repr for the class. Here's an example:"Read more ."You can also increase the verbosity of individual classes (see the documentation), e.g:"If you need more control than the global " function, e.g. if you want to write to several different files in one process, you can create a "" object, e.g: ". Then ", " and  will use that configuration rather than the global one.The arguments are the same as the arguments of  relating to output configuration and .I'd love to hear from users! Obviously " if you have one, but also check out ". There's still a lot more work that can be done and I really want people's opinions so that I can do it right.You can also  what you like or hate about . Just knowing it's being used is helpful. are always welcome!"Please, write tests and run them with ".Tox installs all dependencies automatically. You only need to install Tox itself:If you want to run tests against all target Python versions use " to install them. Otherwise, you can runonly the ones you have already installed on your machine:"Or just install project in developer mode with test dependencies:And run tests:description snoop is a powerful set of Python debugging tools. It's primarily meant to be a  version of . It also includes its own version of  and some other nifty stuff."You're trying to figure out why your Python code isn't doing what you think it should be doing. You'd love to use a full-fledged debugger with breakpoints and watches, but you can't be bothered to set one up right now.""You want to know which lines are running and which aren't, and what the values of the local variables are."Most people would use " lines, in strategic locations, some of them showing the values of variables."" lets you do the same, except instead of carefully crafting the right "" lines, you just add one decorator line to the function you're interested in. You'll get a play-by-play log of your function, including which lines ran and when, and exactly when local variables were changed."Installation is as simple as ."We're writing a function that converts a number to binary, by returning a list of bits. Let's snoop on it by adding the " decorator:Note how easy it is: Just  and ". If you don't like the magical import, " and " still work too. Or if you don't want to import in your project at all, just call " somewhere once.The output to stderr looks like this:Let's try a more complex example. We're writing a memoizing decorator: it stores function arguments and return values in a cache to avoid recomputation:Here we specify  to mean we should also step one level down into inner function calls. We then call the function twice to see the caching in action. Here's the output:At a glance we can see that in the first call the cache lookup failed with a  so the original " function was called, while in the second call the previously cached result was returned immediately.""If you don't want to trace an entire function, you can wrap the relevant part in a " block:which outputs something like:This will output lines like:See  for more advanced usage of this argument.See " to show additional information about any value (local variable, watched expression, or exploded item) automatically."While  is meant to save you from writing " calls, sometimes that's still exactly the kind of thing you need. " aims to be the best possible version of this. It can be used alone or in combination with . will output ", i.e. it will show the source code of its argument(s) so you know what's being printed, and format the value with " so that you can easily see the layout of complicated data structures. If  or  is installed their  will be used instead of ." will return its argument directly so you can easily insert it in code without rearranging. If given multiple arguments, it will return them as a tuple, so you can replace " with  to leave the behaviour of the code intact.Here's an example:Output:If you've already got  you can also use ". But ideally, you would use " to avoid importing at all.There are a few situations where " can't find the source code of its arguments, in which case it will show a placeholder instead:""Under the hood, " uses the library  to locate the AST node of the function call - check it out if you'd like to write some cool utilities of your own. is inspired by " and offers the same basic API for printing, but " integrates seamlessly with  and offers ", which is unique."'' stands for 'pretty-print' and . It's also very easy and quick to type.If you have " and you want to see what happens inside that expression and not just the final value, replace it wth "". This will log every intermediate subexpression, in the correct order, with no additional side effects, and return the final value. Repeating the previous example:"Output:(the values of literals and builtins are left out because they're trivial)"If an exception is raised, it'll show which subexpression is responsible, which looks something like this:""If you like this, you'll probably love ".The  decorator lets you combine  with the powerful debugger . The code:is roughly equivalent to:To reduce the dependencies of ", you'll need to install " separately: .The only big disadvantage of " is that it significantly reduces performance, so avoid it for functions with many loop iterations. Otherwise you can basically always use it instead of "". Then if the logs don't have the information you need you can open up the birdseye UI to see more detail, without needing to edit or rerun your code. Great for when you're feeling lazy and unsure which tool is best." passes its arguments to ", so e.g. " works.('' is so named because it's a combination of the decorator names '' and '')"To make regularly debugging your project more convenient, run this code early on:"Then ", "", and " will be available in every file without needing to import them.You can choose different names by passing keyword arguments ", e.g:"will let you decorate functions with ."If you dislike this feature and would prefer to just import normally, but you want to use "" for other configuration, pass "."As an alternative, in Python 3.7+ you can use the new " function in place of  if you set the environment variable .If you would like to leave " and other functions in your codebase but disable their effects, pass "". For example, if you're using Django, put " in " to automatically disable it in production. When disabled, performance impact is minimised and there is no output anywhere."You can also dynamically re-enable the functions at any point by calling " again, e.g. in a special view or signal handler." has several keyword arguments for controlling the output of  and :If you're familiar with  and want to use ", there are a few things you should be aware of that you have to do differently:"If you're not sure if it's worth using  instead of ", ".snoop comes with an IPython extension that you can use in shells or notebooks.First you need to ", using either " in a notebook cell or by adding  to the list " in your IPython configuration file, e.g. ".Then use the cell magic  at the top of a notebook cell to trace that cell: has another parameter called ". You can pass it a list of functions to automatically show extra information about any value: local variables, watched expressions, and exploded items. For example, suppose you wanted to see the type of every variable. You could define a function like this:"You would then write . The result is output like this:The functions you write should accept two arguments  and " - typically these will be the name of a variable and its actual value. They should return a pair representing the 'source' of the returned information (used only for display, it doesn't have to be valid Python) and the actual information. If you don't want to display anything for this particular value, return ". Any exceptions raised are caught and silenced.Two such functions are already enabled by default: one which shows either the  or the " property (used by numpy, pandas, tensorflow, etc) of values, and one which shows the " property." is added to these two default functions so you don't have to specify them again. If you don't want to include them, use " instead to specify the exact list. The original functions can be found here: will automatically guess how to expand the expression passed to it based on its class. You can be more specific by using one of the following classes:Exclude specific keys/attributes/indices with the " parameter, e.g. ".Add a slice after " to only see the values within that slice, e.g. ".(See also )Values are rendered using the " library to improve performance and avoid flooding the console. It has a specially defined repr function for most common classes, including from third party libraries. If a class is missing, please open an issue there. You can also register your own repr for the class. Here's an example:"Read more ."You can also increase the verbosity of individual classes (see the documentation), e.g:"If you need more control than the global " function, e.g. if you want to write to several different files in one process, you can create a "" object, e.g: ". Then ", " and  will use that configuration rather than the global one.The arguments are the same as the arguments of  relating to output configuration and .I'd love to hear from users! Obviously " if you have one, but also check out ". There's still a lot more work that can be done and I really want people's opinions so that I can do it right.You can also  what you like or hate about . Just knowing it's being used is helpful. are always welcome!"Please, write tests and run them with ".Tox installs all dependencies automatically. You only need to install Tox itself:If you want to run tests against all target Python versions use " to install them. Otherwise, you can runonly the ones you have already installed on your machine:"Or just install project in developer mode with test dependencies:And run tests: