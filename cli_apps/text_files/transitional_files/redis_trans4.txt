descriptionThe Python interface to the Redis key-value store."""""""""" |  |   | redis-py requires a running Redis server. See " for installationinstructions.""redis-py can be installed using pip similar to otherPython packages. Do not use sudo with pip.It is usually good to work in a"" or"" to avoid conflictswith other package managers and Python projects. For a quickintroduction see "."To install redis-py, simply:"or from source:View the current documentation ."Want to contribute a feature, bug fix, or report an issue? Check outour ".redis-py supports Python 3.6+."By default, all responses are returned as bytes in Python3."If " string responses from a client should be decoded, the usercan specify "" in"". In this case, any Redis command thatreturns a string type will be decoded with the encodingspecified.""The default encoding is utf-8, but this can be customized by specifiying theencoding argument for the redis.Redis class.The encoding will be used to automatically encode anystrings passed to commands, such as key names and values.""These commands all accept a mapping of key/value pairs. In redis-py 2.Xthis mapping could be specified as *" or as ". Both ofthese styles caused issues when Redis introduced optional flags to ZADD.Relying on "" caused issues with the optional argument order,especially in Python 2.7. Relying on "" caused potentialcollision issues of user keys with the argument names in the methodsignature.""To resolve this, redis-py 3.0 has changed these three commands to allaccept a single positional argument named mapping that is expected to bea dict. For MSET and MSETNX, the dict is a mapping of key-names ->values. For ZADD, the dict is a mapping of element-names -> score.""MSET, MSETNX and ZADD now look like:""All 2.X users that use these commands must modify their code to supplykeys and values as a dict to these commands.""redis-py 2.X accidentally modified the argument order of ZINCRBY,swapping the order of value and amount. ZINCRBY now looks like:""All 2.X users that rely on ZINCRBY must swap the order of amount andvalue for the command to continue to work as intended.""redis-py 3.0 only accepts user data as bytes, strings or numbers (ints,longs and floats). Attempting to specify a key or a value as any othertype will raise a DataError exception.""redis-py 2.X attempted to coerce any type of input into a string. Whileoccasionally convenient, this caused all sorts of hidden errors whenusers passed boolean values (which were coerced to 'True' or'False'), a None value (which was coerced to 'None') or othervalues, such as user defined types.""All 2.X users should make sure that the keys and values they pass intoredis-py are either bytes, strings or numbers.""redis-py 3.0 drops support for the pipeline-based Lock and now onlysupports the Lua-based lock. In doing so, LuaLock has been renamed toLock. This also means that redis-py Lock objects require Redis server2.6 or greater."2.X users that were explicitly referring to " will have to nowrefer to " instead."redis-py 3.0 now raises a LockError when using a lock as a contextmanager and the lock cannot be acquired within the specified timeout.This is more of a bug fix than a backwards incompatible change. However,given an error is now raised where none was before, this might alarmsome users.""2.X users should make sure they're wrapping their lock code in atry/catch like this:"The "does a great job of explaining each command in detail. redis-py attemptsto adhere to the official command syntax. There are a few exceptions:"redis-py 3.0 drops support for the legacy " client class." has been renamed to " and an alias named"" is provided so that users previously using" can continue to run unchanged.The 2.X " class provided alternative implementations of a fewcommands. This confused users (rightfully so) and caused a number ofsupport issues. To make things easier going forward, it was decided todrop support for these alternate implementations and instead focus on asingle client class.""2.X users that are already using StrictRedis don't have to change theclass name. StrictRedis will continue to work for the foreseeablefuture.""2.X users that are using the Redis class will have to make changes ifthey use any of the following commands:""Behind the scenes, redis-py uses a connection pool to manage connectionsto a Redis server. By default, each Redis instance you create will inturn create its own connection pool. You can override this behavior anduse an existing connection pool by passing an already created connectionpool instance to the connection_pool argument of the Redis class. Youmay choose to do this in order to implement client side sharding or havefine-grain control of how connections are managed.""ConnectionPools manage a set of Connection instances. redis-py shipswith two types of Connections. The default, Connection, is a normal TCPsocket based connection. The UnixDomainSocketConnection allows forclients running on the same device as the server to connect via a unixdomain socket. To use a UnixDomainSocketConnection connection, simplypass the unix_socket_path argument, which is a string to the unix domainsocket file. Additionally, make sure the unixsocket parameter is definedin your redis.conf file. It's commented out by default.""You can create your own Connection subclasses as well. This may beuseful if you want to control the socket behavior within an asyncframework. To instantiate a client class using your own connection, youneed to create a connection pool, passing your class to theconnection_class argument. Other keyword parameters you pass to the poolwill be passed to the class specified during initialization.""Connections maintain an open socket to the Redis server. Sometimes thesesockets are interrupted or disconnected for a variety of reasons. Forexample, network appliances, load balancers and other services that sitbetween clients and servers are often configured to kill connectionsthat remain idle for a given threshold.""When a connection becomes disconnected, the next command issued on thatconnection will fail and redis-py will raise a ConnectionError to thecaller. This allows each application that uses redis-py to handle errorsin a way that's fitting for that specific application. However,constant error handling can be verbose and cumbersome, especially whensocket disconnections happen frequently in many production environments.""To combat this, redis-py can issue regular health checks to assess theliveliness of a connection just before issuing a command. Users can pass"" to the Redis or ConnectionPool classes or as aquery argument within a Redis URL. The value of ""must be an integer. A value of "", the default, disables health checks.Any positive integer will enable health checks. Health checks areperformed just before a command is executed if the underlying connectionhas been idle for more than "" seconds. Forexample, "" will ensure that a health check isrun on any connection that has been idle for 30 or more seconds justbefore a command is executed on that connection.""If your application is running in an environment that disconnects idleconnections after 30 seconds you should set the ""option to a value less than 30.""This option also works on any PubSub connection that is created from aclient with "" enabled. PubSub users need to ensurethat " or " are called more frequently than"" seconds. It is assumed that most workloadsalready do this."If your PubSub use case doesn't call  or "frequently, you should call "" explicitly on aregularly basis.""redis-py 3.0 changes the default value of thessl_cert_reqs option from None to'required'. See "". This changeenforces hostname validation when accepting a cert from a remote SSLterminator. If the terminator doesn't properly set the hostname on thecert this will cause redis-py 3.0 to raise a ConnectionError.""This check can be disabled by setting ssl_cert_reqs toNone. Note that doing so removes the security check. Do soat your own risk.""Example with hostname verification using a local certificate bundle(linux):""Example with hostname verification using":Example turning off hostname verification (not recommended):redis-py can be used together with " to discover Redis nodes. Youneed to have at least one Sentinel daemon running in order to useredis-py's Sentinel support.""Connecting redis-py to the Sentinel instance(s) is easy. You can use aSentinel connection to discover the master and slaves network addresses:"To connect to a sentinel which uses SSL ( for more examples of SSL configurations):"You can also create Redis client connections from a Sentinel instance.You can connect to either the master (for write operations) or a slave(for read-only operations).""The master and slave objects are normal Redis instances with theirconnection pool bound to the Sentinel instance. When a Sentinel backedclient attempts to establish a connection, it first queries the Sentinelservers to determine an appropriate host to connect to. If no server isfound, a MasterNotFoundError or SlaveNotFoundError is raised. Bothexceptions are subclasses of ConnectionError.""When trying to connect to a slave client, the Sentinel connection poolwill iterate over the list of slaves until it finds one that can beconnected to. If no slaves can be connected to, a connection will beestablished with the master."See " to learn more aboutRedis Sentinel.""Parser classes provide a way to control how responses from the Redisserver are parsed. redis-py ships with two parser classes, thePythonParser and the HiredisParser. By default, redis-py will attempt touse the HiredisParser if you have the hiredis module installed and willfallback to the PythonParser otherwise.""Hiredis is a C library maintained by the core Redis team. PieterNoordhuis was kind enough to create Python bindings. Using Hiredis canprovide up to a 10x speed improvement in parsing responses from theRedis server. The performance increase is most noticeable whenretrieving many pieces of data, such as from LRANGE or SMEMBERSoperations.""Hiredis is available on PyPI, and can be installed via pip just likeredis-py.""The client class uses a set of callbacks to cast Redis responses to theappropriate Python type. There are a number of these callbacks definedon the Redis client class in a dictionary called RESPONSE_CALLBACKS.""Custom callbacks can be added on a per-instance basis using theset_response_callback method. This method accepts two arguments: acommand name and the callback. Callbacks added in this manner are onlyvalid on the instance the callback is added to. If you want to define oroverride a callback globally, you should make a subclass of the Redisclient and add your callback to its RESPONSE_CALLBACKS class dictionary.""Response callbacks take at least one parameter: the response from theRedis server. Keyword arguments may also be accepted in order to furthercontrol how to interpret the response. These keyword arguments arespecified during the command's call to execute_command. The ZRANGEimplementation demonstrates the use of response callback keywordarguments with its ""withscores"" argument.""Redis client instances can safely be shared between threads. Internally,connection instances are only retrieved from the connection pool duringcommand execution, and returned to the pool directly after. Commandexecution never modifies state on the client instance.""However, there is one caveat: the Redis SELECT command. The SELECTcommand allows you to switch the database currently in use by theconnection. That database remains selected until another is selected oruntil the connection is closed. This creates an issue in thatconnections could be returned to the pool that are connected to adifferent database.""As a result, redis-py does not implement the SELECT command on clientinstances. If you use multiple Redis databases within the sameapplication, you should create a separate client instance (and possiblya separate connection pool) for each database."It is not safe to pass PubSub or Pipeline objects between threads."Pipelines are a subclass of the base Redis class that provide supportfor buffering multiple commands to the server in a single request. Theycan be used to dramatically increase the performance of groups ofcommands by reducing the number of back-and-forth TCP packets betweenthe client and server."Pipelines are quite simple to use:"For ease of use, all commands being buffered into the pipeline returnthe pipeline object itself. Therefore calls can be chained like:""In addition, pipelines can also ensure the buffered commands areexecuted atomically as a group. This happens by default. If you want todisable the atomic nature of a pipeline but still want to buffercommands, you can turn off transactions.""A common issue occurs when requiring atomic transactions but needing toretrieve values in Redis prior for use within the transaction. Forinstance, let's assume that the INCR command didn't exist and we needto build an atomic version of INCR in Python.""The completely naive implementation could GET the value, increment it inPython, and SET the new value back. However, this is not atomic becausemultiple clients could be doing this at the same time, each getting thesame value from GET.""Enter the WATCH command. WATCH provides the ability to monitor one ormore keys prior to starting a transaction. If any of those keys changeprior the execution of that transaction, the entire transaction will becanceled and a WatchError will be raised. To implement our ownclient-side INCR command, we could do something like this:""Note that, because the Pipeline must bind to a single connection for theduration of a WATCH, care must be taken to ensure that the connection isreturned to the connection pool by calling the reset() method. If thePipeline is used as a context manager (as in the example above) reset()will be called automatically. Of course you can do this the manual wayby explicitly calling reset():""A convenience method named ""transaction"" exists for handling all theboilerplate of handling and retrying watch errors. It takes a callablethat should expect a single parameter, a pipeline object, and any numberof keys to be WATCHed. Our client-side INCR command above can be writtenlike this, which is much easier to read:""Be sure to call pipe.multi() in the callable passed toRedis.transaction prior to any write commands.""redis-py includes a PubSub object that subscribes tochannels and listens for new messages. Creating a PubSubobject is easy.""Once a PubSub instance is created, channels and patternscan be subscribed to.""The PubSub instance is now subscribed to thosechannels/patterns. The subscription confirmations can be seen by readingmessages from the PubSub instance.""Every message read from a PubSub instance will be adictionary with the following keys."Let's send a message now."Unsubscribing works just like subscribing. If no arguments are passed to[p]unsubscribe, all channels or patterns will be unsubscribed from.""redis-py also allows you to register callback functions to handlepublished messages. Message handlers take a single argument, themessage, which is a dictionary just like the examples above. Tosubscribe to a channel or pattern with a message handler, pass thechannel or pattern name as a keyword argument with its value being thecallback function.""When a message is read on a channel or pattern with a message handler,the message dictionary is created and passed to the message handler. Inthis case, a None value is returned from get_message()since the message was already handled.""If your application is not interested in the (sometimes noisy)subscribe/unsubscribe confirmation messages, you can ignore them bypassing ignore_subscribe_messages=True tor.pubsub(). This will cause all subscribe/unsubscribemessages to be read, but they won't bubble up to your application."There are three different strategies for reading messages."The examples above have been using pubsub.get_message().Behind the scenes, get_message() uses the system's'select' module to quickly poll the connection's socket. If there'sdata available to be read, get_message() will read it,format the message and return it or pass it to a message handler. Ifthere's no data to be read, get_message() willimmediately return None. This makes it trivial to integrate into anexisting event loop inside your application.""Older versions of redis-py only read messages withpubsub.listen(). listen() is a generator that blocks untila message is available. If your application doesn't need to do anythingelse but receive and act on messages received from redis, listen() is aneasy way to get up an running.""The third option runs an event loop in a separate thread.pubsub.run_in_thread() creates a new thread and starts theevent loop. The thread object is returned to the caller of[un_in_thread(). The caller can use thethread.stop() method to shut down the event loop andthread. Behind the scenes, this is simply a wrapper aroundget_message() that runs in a separate thread, essentiallycreating a tiny non-blocking event loop for you.run_in_thread() takes an optional sleep_timeargument. If specified, the event loop will calltime.sleep() with the value in each iteration of the loop.""Note: Since we're running in a separate thread, there's no way tohandle messages that aren't automatically handled with registeredmessage handlers. Therefore, redis-py prevents you from callingrun_in_thread() if you're subscribed to patterns orchannels that don't have message handlers attached.""run_in_thread also supports an optional exception handler,which lets you catch exceptions that occur within the worker thread andhandle them appropriately. The exception handler will take as argumentsthe exception itself, the pubsub object, and the worker thread returnedby run_in_thread.""A PubSub object adheres to the same encoding semantics as the clientinstance it was created from. Any channel or pattern that's unicodewill be encoded using the charset specified on the clientbefore being sent to Redis. If the client'sdecode_responses flag is set the False (the default), the'channel', 'pattern' and 'data' values in message dictionarieswill be byte strings (str on Python 2, bytes on Python 3). If theclient's decode_responses is True, then the 'channel','pattern' and 'data' values will be automatically decoded to unicodestrings using the client's charset.""PubSub objects remember what channels and patterns they are subscribedto. In the event of a disconnection such as a network error or timeout,the PubSub object will re-subscribe to all prior channels and patternswhen reconnecting. Messages that were published while the client wasdisconnected cannot be delivered. When you're finished with a PubSubobject, call its .close() method to shutdown theconnection.""The PUBSUB set of subcommands CHANNELS, NUMSUB and NUMPAT are alsosupported:""redis-py includes a Monitor object that streams everycommand processed by the Redis server. Use listen() on theMonitor object to block until a command is received.""redis-py supports the EVAL, EVALSHA, and SCRIPT commands. However, thereare a number of edge cases that make these commands tedious to use inreal world scenarios. Therefore, redis-py exposes a Script object thatmakes scripting much easier to use.""To create a Script instance, use the register_scriptfunction on a client instance passing the Lua code as the firstargument. register_script returns a Script instance thatyou can use throughout your code.""The following trivial Lua script accepts two parameters: the name of akey and a multiplier value. The script fetches the value stored in thekey, multiplies it with the multiplier value and returns the result.""multiply is now a Script instance that is invoked bycalling it like a function. Script instances accept the followingoptional arguments:"Continuing the example from above:"The value of key 'foo' is set to 2. When multiply is invoked, the'foo' key is passed to the script along with the multiplier value of5. Lua executes the script and returns the result, 10.""Script instances can be executed using a different client instance, evenone that points to a completely different Redis server.""The Script object ensures that the Lua script is loaded into Redis'sscript cache. In the event of a NOSCRIPT error, it will load the scriptand retry executing it.""Script objects can also be used in pipelines. The pipeline instanceshould be passed as the client argument when calling the script. Care istaken to ensure that the script is registered in Redis's script cachejust prior to pipeline execution.""The *SCAN commands introduced in Redis 2.8 can be cumbersome to use.While these commands are fully supported, redis-py also exposes thefollowing methods that return Python iterators for convenience:scan_iter, hscan_iter,sscan_iter and zscan_iter.""redis-py is now supports cluster mode and provides a client for"."The cluster client is based on Grokzen's"", has added bugfixes, and now supersedes that library. Support for these changes is thanks tohis contributions.""Connecting redis-py to a Redis Cluster instance(s) requires at a minimum asingle node for cluster discovery. There are multiple ways in which a clusterinstance can be created:""When a RedisCluster instance is being created it first attempts to establish aconnection to one of the provided startup nodes. If none of the startup nodesare reachable, a 'RedisClusterException' will be thrown.After a connection to the one of the cluster's nodes is established, theRedisCluster instance will be initialized with 3 caches:a slots cache which maps each of the 16384 slots to the node/s handling them,a nodes cache that contains ClusterNode objects (name, host, port, redis connection)for all of the cluster's nodes, and a commands cache contains all the serversupported commands that were retrieved using the Redis 'COMMAND' output.""RedisCluster instance can be directly used to execute Redis commands. When acommand is being executed through the cluster instance, the target node(s) willbe internally determined. When using a key-based command, the target node willbe the node that holds the key's slot.Cluster management commands and other commands that are not key-based have aparameter called 'target_nodes' where you can specify which nodes to executethe command on. In the absence of target_nodes, the command will be executedon the default cluster node. As part of cluster instance initialization, thecluster's default node is randomly selected from the cluster's primaries, andwill be updated upon reinitialization. Using r.get_default_node(), you canget the cluster's default node, or you can change it using the'set_default_node' method.""The 'target_nodes' parameter is explained in the following section,'Specifying Target Nodes'.""As mentioned above, all non key-based RedisCluster commands accept the kwargparameter 'target_nodes' that specifies the node/nodes that the command shouldbe executed on.The best practice is to specify target nodes using RedisCluster class's nodeflags: PRIMARIES, REPLICAS, ALL_NODES, RANDOM. When a nodes flag is passedalong with a command, it will be internally resolved to the relevant node/s.If the nodes topology of the cluster changes during the execution of a command,the client will be able to resolve the nodes flag again with the new topologyand attempt to retry executing the command.""You could also pass ClusterNodes directly if you want to execute a command on aspecific node / node group that isn't addressed by the nodes flag. However, ifthe command execution fails due to cluster topology changes, a retry attemptwill not be made, since the passed target node/s may no longer be valid, andthe relevant cluster or connection error will be returned.""In addition, the RedisCluster instance can query the Redis instance of aspecific node and execute commands on that node directly. The Redis client,however, does not handle cluster failures and retries.""Redis supports multi-key commands in Cluster Mode, such as Set type unions orintersections, mset and mget, as long as the keys all hash to the same slot.By using RedisCluster client, you can use the known functions (e.g. mget, mset)to perform an atomic multi-key operation. However, you must ensure all keys aremapped to the same slot, otherwise a RedisClusterException will be thrown.Redis Cluster implements a concept called hash tags that can be used in orderto force certain keys to be stored in the same hash slot, see"".You can also use nonatomic for some of the multikey operations, and pass keysthat aren't mapped to the same slot. The client will then map the keys to therelevant slots, sending the commands to the slots' node owners. Non-atomicoperations batch the keys according to their hash value, and then each batch issent separately to the slot's owner.""When a ClusterPubSub instance is created without specifying a node, a singlenode will be transparently chosen for the pubsub connection on thefirst command execution. The node will be determined by:""Pattern subscribe and publish do not currently work properly due to key slots.If we hash a pattern like fo* we will receive a keyslot for that string butthere are endless possibilities for channel names based on this pattern -unknowable in advance. This feature is not disabled but the commands are notcurrently recommended for use.See ""for more.""By default, Redis Cluster always returns MOVE redirection response on accessinga replica node. You can overcome this limitation and scale read commands bytriggering READONLY mode.""To enable READONLY mode pass read_from_replicas=True to RedisClusterconstructor. When set to true, read commands will be assigned between theprimary and its replications in a Round-Robin manner.""READONLY mode can be set at runtime by calling the readonly() method withtarget_nodes='replicas', and read-write access can be restored by calling thereadwrite() method.""ClusterPipeline is a subclass of RedisCluster that provides support for Redispipelines in cluster mode.When calling the execute() command, all the commands are grouped by the nodeon which they will be executed, and are then executed by the respective nodesin parallel. The pipeline instance will wait for all the nodes to respondbefore returning the result to the caller. Command responses are returned as alist sorted in the same order in which they were sent.Pipelines can be used to dramatically increase the throughput of Redis Clusterby significantly reducing the the number of network round trips between theclient and the server."Please note:See " and""to learn more about Redis Cluster."redis-py is developed and maintained by . It can be found ", or downloaded from ".Special thanks to:descriptionThe Python interface to the Redis key-value store."""""""""" |  |   | redis-py requires a running Redis server. See " for installationinstructions.""redis-py can be installed using pip similar to otherPython packages. Do not use sudo with pip.It is usually good to work in a"" or"" to avoid conflictswith other package managers and Python projects. For a quickintroduction see "."To install redis-py, simply:"or from source:View the current documentation ."Want to contribute a feature, bug fix, or report an issue? Check outour ".redis-py supports Python 3.6+."By default, all responses are returned as bytes in Python3."If " string responses from a client should be decoded, the usercan specify "" in"". In this case, any Redis command thatreturns a string type will be decoded with the encodingspecified.""The default encoding is utf-8, but this can be customized by specifiying theencoding argument for the redis.Redis class.The encoding will be used to automatically encode anystrings passed to commands, such as key names and values.""These commands all accept a mapping of key/value pairs. In redis-py 2.Xthis mapping could be specified as *" or as ". Both ofthese styles caused issues when Redis introduced optional flags to ZADD.Relying on "" caused issues with the optional argument order,especially in Python 2.7. Relying on "" caused potentialcollision issues of user keys with the argument names in the methodsignature.""To resolve this, redis-py 3.0 has changed these three commands to allaccept a single positional argument named mapping that is expected to bea dict. For MSET and MSETNX, the dict is a mapping of key-names ->values. For ZADD, the dict is a mapping of element-names -> score.""MSET, MSETNX and ZADD now look like:""All 2.X users that use these commands must modify their code to supplykeys and values as a dict to these commands.""redis-py 2.X accidentally modified the argument order of ZINCRBY,swapping the order of value and amount. ZINCRBY now looks like:""All 2.X users that rely on ZINCRBY must swap the order of amount andvalue for the command to continue to work as intended.""redis-py 3.0 only accepts user data as bytes, strings or numbers (ints,longs and floats). Attempting to specify a key or a value as any othertype will raise a DataError exception.""redis-py 2.X attempted to coerce any type of input into a string. Whileoccasionally convenient, this caused all sorts of hidden errors whenusers passed boolean values (which were coerced to 'True' or'False'), a None value (which was coerced to 'None') or othervalues, such as user defined types.""All 2.X users should make sure that the keys and values they pass intoredis-py are either bytes, strings or numbers.""redis-py 3.0 drops support for the pipeline-based Lock and now onlysupports the Lua-based lock. In doing so, LuaLock has been renamed toLock. This also means that redis-py Lock objects require Redis server2.6 or greater."2.X users that were explicitly referring to " will have to nowrefer to " instead."redis-py 3.0 now raises a LockError when using a lock as a contextmanager and the lock cannot be acquired within the specified timeout.This is more of a bug fix than a backwards incompatible change. However,given an error is now raised where none was before, this might alarmsome users.""2.X users should make sure they're wrapping their lock code in atry/catch like this:"The "does a great job of explaining each command in detail. redis-py attemptsto adhere to the official command syntax. There are a few exceptions:"redis-py 3.0 drops support for the legacy " client class." has been renamed to " and an alias named"" is provided so that users previously using" can continue to run unchanged.The 2.X " class provided alternative implementations of a fewcommands. This confused users (rightfully so) and caused a number ofsupport issues. To make things easier going forward, it was decided todrop support for these alternate implementations and instead focus on asingle client class.""2.X users that are already using StrictRedis don't have to change theclass name. StrictRedis will continue to work for the foreseeablefuture.""2.X users that are using the Redis class will have to make changes ifthey use any of the following commands:""Behind the scenes, redis-py uses a connection pool to manage connectionsto a Redis server. By default, each Redis instance you create will inturn create its own connection pool. You can override this behavior anduse an existing connection pool by passing an already created connectionpool instance to the connection_pool argument of the Redis class. Youmay choose to do this in order to implement client side sharding or havefine-grain control of how connections are managed.""ConnectionPools manage a set of Connection instances. redis-py shipswith two types of Connections. The default, Connection, is a normal TCPsocket based connection. The UnixDomainSocketConnection allows forclients running on the same device as the server to connect via a unixdomain socket. To use a UnixDomainSocketConnection connection, simplypass the unix_socket_path argument, which is a string to the unix domainsocket file. Additionally, make sure the unixsocket parameter is definedin your redis.conf file. It's commented out by default.""You can create your own Connection subclasses as well. This may beuseful if you want to control the socket behavior within an asyncframework. To instantiate a client class using your own connection, youneed to create a connection pool, passing your class to theconnection_class argument. Other keyword parameters you pass to the poolwill be passed to the class specified during initialization.""Connections maintain an open socket to the Redis server. Sometimes thesesockets are interrupted or disconnected for a variety of reasons. Forexample, network appliances, load balancers and other services that sitbetween clients and servers are often configured to kill connectionsthat remain idle for a given threshold.""When a connection becomes disconnected, the next command issued on thatconnection will fail and redis-py will raise a ConnectionError to thecaller. This allows each application that uses redis-py to handle errorsin a way that's fitting for that specific application. However,constant error handling can be verbose and cumbersome, especially whensocket disconnections happen frequently in many production environments.""To combat this, redis-py can issue regular health checks to assess theliveliness of a connection just before issuing a command. Users can pass"" to the Redis or ConnectionPool classes or as aquery argument within a Redis URL. The value of ""must be an integer. A value of "", the default, disables health checks.Any positive integer will enable health checks. Health checks areperformed just before a command is executed if the underlying connectionhas been idle for more than "" seconds. Forexample, "" will ensure that a health check isrun on any connection that has been idle for 30 or more seconds justbefore a command is executed on that connection.""If your application is running in an environment that disconnects idleconnections after 30 seconds you should set the ""option to a value less than 30.""This option also works on any PubSub connection that is created from aclient with "" enabled. PubSub users need to ensurethat " or " are called more frequently than"" seconds. It is assumed that most workloadsalready do this."If your PubSub use case doesn't call  or "frequently, you should call "" explicitly on aregularly basis.""redis-py 3.0 changes the default value of thessl_cert_reqs option from None to'required'. See "". This changeenforces hostname validation when accepting a cert from a remote SSLterminator. If the terminator doesn't properly set the hostname on thecert this will cause redis-py 3.0 to raise a ConnectionError.""This check can be disabled by setting ssl_cert_reqs toNone. Note that doing so removes the security check. Do soat your own risk.""Example with hostname verification using a local certificate bundle(linux):""Example with hostname verification using":Example turning off hostname verification (not recommended):redis-py can be used together with " to discover Redis nodes. Youneed to have at least one Sentinel daemon running in order to useredis-py's Sentinel support.""Connecting redis-py to the Sentinel instance(s) is easy. You can use aSentinel connection to discover the master and slaves network addresses:"To connect to a sentinel which uses SSL ( for more examples of SSL configurations):"You can also create Redis client connections from a Sentinel instance.You can connect to either the master (for write operations) or a slave(for read-only operations).""The master and slave objects are normal Redis instances with theirconnection pool bound to the Sentinel instance. When a Sentinel backedclient attempts to establish a connection, it first queries the Sentinelservers to determine an appropriate host to connect to. If no server isfound, a MasterNotFoundError or SlaveNotFoundError is raised. Bothexceptions are subclasses of ConnectionError.""When trying to connect to a slave client, the Sentinel connection poolwill iterate over the list of slaves until it finds one that can beconnected to. If no slaves can be connected to, a connection will beestablished with the master."See " to learn more aboutRedis Sentinel.""Parser classes provide a way to control how responses from the Redisserver are parsed. redis-py ships with two parser classes, thePythonParser and the HiredisParser. By default, redis-py will attempt touse the HiredisParser if you have the hiredis module installed and willfallback to the PythonParser otherwise.""Hiredis is a C library maintained by the core Redis team. PieterNoordhuis was kind enough to create Python bindings. Using Hiredis canprovide up to a 10x speed improvement in parsing responses from theRedis server. The performance increase is most noticeable whenretrieving many pieces of data, such as from LRANGE or SMEMBERSoperations.""Hiredis is available on PyPI, and can be installed via pip just likeredis-py.""The client class uses a set of callbacks to cast Redis responses to theappropriate Python type. There are a number of these callbacks definedon the Redis client class in a dictionary called RESPONSE_CALLBACKS.""Custom callbacks can be added on a per-instance basis using theset_response_callback method. This method accepts two arguments: acommand name and the callback. Callbacks added in this manner are onlyvalid on the instance the callback is added to. If you want to define oroverride a callback globally, you should make a subclass of the Redisclient and add your callback to its RESPONSE_CALLBACKS class dictionary.""Response callbacks take at least one parameter: the response from theRedis server. Keyword arguments may also be accepted in order to furthercontrol how to interpret the response. These keyword arguments arespecified during the command's call to execute_command. The ZRANGEimplementation demonstrates the use of response callback keywordarguments with its ""withscores"" argument.""Redis client instances can safely be shared between threads. Internally,connection instances are only retrieved from the connection pool duringcommand execution, and returned to the pool directly after. Commandexecution never modifies state on the client instance.""However, there is one caveat: the Redis SELECT command. The SELECTcommand allows you to switch the database currently in use by theconnection. That database remains selected until another is selected oruntil the connection is closed. This creates an issue in thatconnections could be returned to the pool that are connected to adifferent database.""As a result, redis-py does not implement the SELECT command on clientinstances. If you use multiple Redis databases within the sameapplication, you should create a separate client instance (and possiblya separate connection pool) for each database."It is not safe to pass PubSub or Pipeline objects between threads."Pipelines are a subclass of the base Redis class that provide supportfor buffering multiple commands to the server in a single request. Theycan be used to dramatically increase the performance of groups ofcommands by reducing the number of back-and-forth TCP packets betweenthe client and server."Pipelines are quite simple to use:"For ease of use, all commands being buffered into the pipeline returnthe pipeline object itself. Therefore calls can be chained like:""In addition, pipelines can also ensure the buffered commands areexecuted atomically as a group. This happens by default. If you want todisable the atomic nature of a pipeline but still want to buffercommands, you can turn off transactions.""A common issue occurs when requiring atomic transactions but needing toretrieve values in Redis prior for use within the transaction. Forinstance, let's assume that the INCR command didn't exist and we needto build an atomic version of INCR in Python.""The completely naive implementation could GET the value, increment it inPython, and SET the new value back. However, this is not atomic becausemultiple clients could be doing this at the same time, each getting thesame value from GET.""Enter the WATCH command. WATCH provides the ability to monitor one ormore keys prior to starting a transaction. If any of those keys changeprior the execution of that transaction, the entire transaction will becanceled and a WatchError will be raised. To implement our ownclient-side INCR command, we could do something like this:""Note that, because the Pipeline must bind to a single connection for theduration of a WATCH, care must be taken to ensure that the connection isreturned to the connection pool by calling the reset() method. If thePipeline is used as a context manager (as in the example above) reset()will be called automatically. Of course you can do this the manual wayby explicitly calling reset():""A convenience method named ""transaction"" exists for handling all theboilerplate of handling and retrying watch errors. It takes a callablethat should expect a single parameter, a pipeline object, and any numberof keys to be WATCHed. Our client-side INCR command above can be writtenlike this, which is much easier to read:""Be sure to call pipe.multi() in the callable passed toRedis.transaction prior to any write commands.""redis-py includes a PubSub object that subscribes tochannels and listens for new messages. Creating a PubSubobject is easy.""Once a PubSub instance is created, channels and patternscan be subscribed to.""The PubSub instance is now subscribed to thosechannels/patterns. The subscription confirmations can be seen by readingmessages from the PubSub instance.""Every message read from a PubSub instance will be adictionary with the following keys."Let's send a message now."Unsubscribing works just like subscribing. If no arguments are passed to[p]unsubscribe, all channels or patterns will be unsubscribed from.""redis-py also allows you to register callback functions to handlepublished messages. Message handlers take a single argument, themessage, which is a dictionary just like the examples above. Tosubscribe to a channel or pattern with a message handler, pass thechannel or pattern name as a keyword argument with its value being thecallback function.""When a message is read on a channel or pattern with a message handler,the message dictionary is created and passed to the message handler. Inthis case, a None value is returned from get_message()since the message was already handled.""If your application is not interested in the (sometimes noisy)subscribe/unsubscribe confirmation messages, you can ignore them bypassing ignore_subscribe_messages=True tor.pubsub(). This will cause all subscribe/unsubscribemessages to be read, but they won't bubble up to your application."There are three different strategies for reading messages."The examples above have been using pubsub.get_message().Behind the scenes, get_message() uses the system's'select' module to quickly poll the connection's socket. If there'sdata available to be read, get_message() will read it,format the message and return it or pass it to a message handler. Ifthere's no data to be read, get_message() willimmediately return None. This makes it trivial to integrate into anexisting event loop inside your application.""Older versions of redis-py only read messages withpubsub.listen(). listen() is a generator that blocks untila message is available. If your application doesn't need to do anythingelse but receive and act on messages received from redis, listen() is aneasy way to get up an running.""The third option runs an event loop in a separate thread.pubsub.run_in_thread() creates a new thread and starts theevent loop. The thread object is returned to the caller of[un_in_thread(). The caller can use thethread.stop() method to shut down the event loop andthread. Behind the scenes, this is simply a wrapper aroundget_message() that runs in a separate thread, essentiallycreating a tiny non-blocking event loop for you.run_in_thread() takes an optional sleep_timeargument. If specified, the event loop will calltime.sleep() with the value in each iteration of the loop.""Note: Since we're running in a separate thread, there's no way tohandle messages that aren't automatically handled with registeredmessage handlers. Therefore, redis-py prevents you from callingrun_in_thread() if you're subscribed to patterns orchannels that don't have message handlers attached.""run_in_thread also supports an optional exception handler,which lets you catch exceptions that occur within the worker thread andhandle them appropriately. The exception handler will take as argumentsthe exception itself, the pubsub object, and the worker thread returnedby run_in_thread.""A PubSub object adheres to the same encoding semantics as the clientinstance it was created from. Any channel or pattern that's unicodewill be encoded using the charset specified on the clientbefore being sent to Redis. If the client'sdecode_responses flag is set the False (the default), the'channel', 'pattern' and 'data' values in message dictionarieswill be byte strings (str on Python 2, bytes on Python 3). If theclient's decode_responses is True, then the 'channel','pattern' and 'data' values will be automatically decoded to unicodestrings using the client's charset.""PubSub objects remember what channels and patterns they are subscribedto. In the event of a disconnection such as a network error or timeout,the PubSub object will re-subscribe to all prior channels and patternswhen reconnecting. Messages that were published while the client wasdisconnected cannot be delivered. When you're finished with a PubSubobject, call its .close() method to shutdown theconnection.""The PUBSUB set of subcommands CHANNELS, NUMSUB and NUMPAT are alsosupported:""redis-py includes a Monitor object that streams everycommand processed by the Redis server. Use listen() on theMonitor object to block until a command is received.""redis-py supports the EVAL, EVALSHA, and SCRIPT commands. However, thereare a number of edge cases that make these commands tedious to use inreal world scenarios. Therefore, redis-py exposes a Script object thatmakes scripting much easier to use.""To create a Script instance, use the register_scriptfunction on a client instance passing the Lua code as the firstargument. register_script returns a Script instance thatyou can use throughout your code.""The following trivial Lua script accepts two parameters: the name of akey and a multiplier value. The script fetches the value stored in thekey, multiplies it with the multiplier value and returns the result.""multiply is now a Script instance that is invoked bycalling it like a function. Script instances accept the followingoptional arguments:"Continuing the example from above:"The value of key 'foo' is set to 2. When multiply is invoked, the'foo' key is passed to the script along with the multiplier value of5. Lua executes the script and returns the result, 10.""Script instances can be executed using a different client instance, evenone that points to a completely different Redis server.""The Script object ensures that the Lua script is loaded into Redis'sscript cache. In the event of a NOSCRIPT error, it will load the scriptand retry executing it.""Script objects can also be used in pipelines. The pipeline instanceshould be passed as the client argument when calling the script. Care istaken to ensure that the script is registered in Redis's script cachejust prior to pipeline execution.""The *SCAN commands introduced in Redis 2.8 can be cumbersome to use.While these commands are fully supported, redis-py also exposes thefollowing methods that return Python iterators for convenience:scan_iter, hscan_iter,sscan_iter and zscan_iter.""redis-py is now supports cluster mode and provides a client for"."The cluster client is based on Grokzen's"", has added bugfixes, and now supersedes that library. Support for these changes is thanks tohis contributions.""Connecting redis-py to a Redis Cluster instance(s) requires at a minimum asingle node for cluster discovery. There are multiple ways in which a clusterinstance can be created:""When a RedisCluster instance is being created it first attempts to establish aconnection to one of the provided startup nodes. If none of the startup nodesare reachable, a 'RedisClusterException' will be thrown.After a connection to the one of the cluster's nodes is established, theRedisCluster instance will be initialized with 3 caches:a slots cache which maps each of the 16384 slots to the node/s handling them,a nodes cache that contains ClusterNode objects (name, host, port, redis connection)for all of the cluster's nodes, and a commands cache contains all the serversupported commands that were retrieved using the Redis 'COMMAND' output.""RedisCluster instance can be directly used to execute Redis commands. When acommand is being executed through the cluster instance, the target node(s) willbe internally determined. When using a key-based command, the target node willbe the node that holds the key's slot.Cluster management commands and other commands that are not key-based have aparameter called 'target_nodes' where you can specify which nodes to executethe command on. In the absence of target_nodes, the command will be executedon the default cluster node. As part of cluster instance initialization, thecluster's default node is randomly selected from the cluster's primaries, andwill be updated upon reinitialization. Using r.get_default_node(), you canget the cluster's default node, or you can change it using the'set_default_node' method.""The 'target_nodes' parameter is explained in the following section,'Specifying Target Nodes'.""As mentioned above, all non key-based RedisCluster commands accept the kwargparameter 'target_nodes' that specifies the node/nodes that the command shouldbe executed on.The best practice is to specify target nodes using RedisCluster class's nodeflags: PRIMARIES, REPLICAS, ALL_NODES, RANDOM. When a nodes flag is passedalong with a command, it will be internally resolved to the relevant node/s.If the nodes topology of the cluster changes during the execution of a command,the client will be able to resolve the nodes flag again with the new topologyand attempt to retry executing the command.""You could also pass ClusterNodes directly if you want to execute a command on aspecific node / node group that isn't addressed by the nodes flag. However, ifthe command execution fails due to cluster topology changes, a retry attemptwill not be made, since the passed target node/s may no longer be valid, andthe relevant cluster or connection error will be returned.""In addition, the RedisCluster instance can query the Redis instance of aspecific node and execute commands on that node directly. The Redis client,however, does not handle cluster failures and retries.""Redis supports multi-key commands in Cluster Mode, such as Set type unions orintersections, mset and mget, as long as the keys all hash to the same slot.By using RedisCluster client, you can use the known functions (e.g. mget, mset)to perform an atomic multi-key operation. However, you must ensure all keys aremapped to the same slot, otherwise a RedisClusterException will be thrown.Redis Cluster implements a concept called hash tags that can be used in orderto force certain keys to be stored in the same hash slot, see"".You can also use nonatomic for some of the multikey operations, and pass keysthat aren't mapped to the same slot. The client will then map the keys to therelevant slots, sending the commands to the slots' node owners. Non-atomicoperations batch the keys according to their hash value, and then each batch issent separately to the slot's owner.""When a ClusterPubSub instance is created without specifying a node, a singlenode will be transparently chosen for the pubsub connection on thefirst command execution. The node will be determined by:""Pattern subscribe and publish do not currently work properly due to key slots.If we hash a pattern like fo* we will receive a keyslot for that string butthere are endless possibilities for channel names based on this pattern -unknowable in advance. This feature is not disabled but the commands are notcurrently recommended for use.See ""for more.""By default, Redis Cluster always returns MOVE redirection response on accessinga replica node. You can overcome this limitation and scale read commands bytriggering READONLY mode.""To enable READONLY mode pass read_from_replicas=True to RedisClusterconstructor. When set to true, read commands will be assigned between theprimary and its replications in a Round-Robin manner.""READONLY mode can be set at runtime by calling the readonly() method withtarget_nodes='replicas', and read-write access can be restored by calling thereadwrite() method.""ClusterPipeline is a subclass of RedisCluster that provides support for Redispipelines in cluster mode.When calling the execute() command, all the commands are grouped by the nodeon which they will be executed, and are then executed by the respective nodesin parallel. The pipeline instance will wait for all the nodes to respondbefore returning the result to the caller. Command responses are returned as alist sorted in the same order in which they were sent.Pipelines can be used to dramatically increase the throughput of Redis Clusterby significantly reducing the the number of network round trips between theclient and the server."Please note:See " and""to learn more about Redis Cluster."redis-py is developed and maintained by . It can be found ", or downloaded from ".Special thanks to:descriptionThe Python interface to the Redis key-value store."""""""""" |  |   | redis-py requires a running Redis server. See " for installationinstructions.""redis-py can be installed using pip similar to otherPython packages. Do not use sudo with pip.It is usually good to work in a"" or"" to avoid conflictswith other package managers and Python projects. For a quickintroduction see "."To install redis-py, simply:"or from source:View the current documentation ."Want to contribute a feature, bug fix, or report an issue? Check outour ".redis-py supports Python 3.6+."By default, all responses are returned as bytes in Python3."If " string responses from a client should be decoded, the usercan specify "" in"". In this case, any Redis command thatreturns a string type will be decoded with the encodingspecified.""The default encoding is utf-8, but this can be customized by specifiying theencoding argument for the redis.Redis class.The encoding will be used to automatically encode anystrings passed to commands, such as key names and values.""These commands all accept a mapping of key/value pairs. In redis-py 2.Xthis mapping could be specified as *" or as ". Both ofthese styles caused issues when Redis introduced optional flags to ZADD.Relying on "" caused issues with the optional argument order,especially in Python 2.7. Relying on "" caused potentialcollision issues of user keys with the argument names in the methodsignature.""To resolve this, redis-py 3.0 has changed these three commands to allaccept a single positional argument named mapping that is expected to bea dict. For MSET and MSETNX, the dict is a mapping of key-names ->values. For ZADD, the dict is a mapping of element-names -> score.""MSET, MSETNX and ZADD now look like:""All 2.X users that use these commands must modify their code to supplykeys and values as a dict to these commands.""redis-py 2.X accidentally modified the argument order of ZINCRBY,swapping the order of value and amount. ZINCRBY now looks like:""All 2.X users that rely on ZINCRBY must swap the order of amount andvalue for the command to continue to work as intended.""redis-py 3.0 only accepts user data as bytes, strings or numbers (ints,longs and floats). Attempting to specify a key or a value as any othertype will raise a DataError exception.""redis-py 2.X attempted to coerce any type of input into a string. Whileoccasionally convenient, this caused all sorts of hidden errors whenusers passed boolean values (which were coerced to 'True' or'False'), a None value (which was coerced to 'None') or othervalues, such as user defined types.""All 2.X users should make sure that the keys and values they pass intoredis-py are either bytes, strings or numbers.""redis-py 3.0 drops support for the pipeline-based Lock and now onlysupports the Lua-based lock. In doing so, LuaLock has been renamed toLock. This also means that redis-py Lock objects require Redis server2.6 or greater."2.X users that were explicitly referring to " will have to nowrefer to " instead."redis-py 3.0 now raises a LockError when using a lock as a contextmanager and the lock cannot be acquired within the specified timeout.This is more of a bug fix than a backwards incompatible change. However,given an error is now raised where none was before, this might alarmsome users.""2.X users should make sure they're wrapping their lock code in atry/catch like this:"The "does a great job of explaining each command in detail. redis-py attemptsto adhere to the official command syntax. There are a few exceptions:"redis-py 3.0 drops support for the legacy " client class." has been renamed to " and an alias named"" is provided so that users previously using" can continue to run unchanged.The 2.X " class provided alternative implementations of a fewcommands. This confused users (rightfully so) and caused a number ofsupport issues. To make things easier going forward, it was decided todrop support for these alternate implementations and instead focus on asingle client class.""2.X users that are already using StrictRedis don't have to change theclass name. StrictRedis will continue to work for the foreseeablefuture.""2.X users that are using the Redis class will have to make changes ifthey use any of the following commands:""Behind the scenes, redis-py uses a connection pool to manage connectionsto a Redis server. By default, each Redis instance you create will inturn create its own connection pool. You can override this behavior anduse an existing connection pool by passing an already created connectionpool instance to the connection_pool argument of the Redis class. Youmay choose to do this in order to implement client side sharding or havefine-grain control of how connections are managed.""ConnectionPools manage a set of Connection instances. redis-py shipswith two types of Connections. The default, Connection, is a normal TCPsocket based connection. The UnixDomainSocketConnection allows forclients running on the same device as the server to connect via a unixdomain socket. To use a UnixDomainSocketConnection connection, simplypass the unix_socket_path argument, which is a string to the unix domainsocket file. Additionally, make sure the unixsocket parameter is definedin your redis.conf file. It's commented out by default.""You can create your own Connection subclasses as well. This may beuseful if you want to control the socket behavior within an asyncframework. To instantiate a client class using your own connection, youneed to create a connection pool, passing your class to theconnection_class argument. Other keyword parameters you pass to the poolwill be passed to the class specified during initialization.""Connections maintain an open socket to the Redis server. Sometimes thesesockets are interrupted or disconnected for a variety of reasons. Forexample, network appliances, load balancers and other services that sitbetween clients and servers are often configured to kill connectionsthat remain idle for a given threshold.""When a connection becomes disconnected, the next command issued on thatconnection will fail and redis-py will raise a ConnectionError to thecaller. This allows each application that uses redis-py to handle errorsin a way that's fitting for that specific application. However,constant error handling can be verbose and cumbersome, especially whensocket disconnections happen frequently in many production environments.""To combat this, redis-py can issue regular health checks to assess theliveliness of a connection just before issuing a command. Users can pass"" to the Redis or ConnectionPool classes or as aquery argument within a Redis URL. The value of ""must be an integer. A value of "", the default, disables health checks.Any positive integer will enable health checks. Health checks areperformed just before a command is executed if the underlying connectionhas been idle for more than "" seconds. Forexample, "" will ensure that a health check isrun on any connection that has been idle for 30 or more seconds justbefore a command is executed on that connection.""If your application is running in an environment that disconnects idleconnections after 30 seconds you should set the ""option to a value less than 30.""This option also works on any PubSub connection that is created from aclient with "" enabled. PubSub users need to ensurethat " or " are called more frequently than"" seconds. It is assumed that most workloadsalready do this."If your PubSub use case doesn't call  or "frequently, you should call "" explicitly on aregularly basis.""redis-py 3.0 changes the default value of thessl_cert_reqs option from None to'required'. See "". This changeenforces hostname validation when accepting a cert from a remote SSLterminator. If the terminator doesn't properly set the hostname on thecert this will cause redis-py 3.0 to raise a ConnectionError.""This check can be disabled by setting ssl_cert_reqs toNone. Note that doing so removes the security check. Do soat your own risk.""Example with hostname verification using a local certificate bundle(linux):""Example with hostname verification using":Example turning off hostname verification (not recommended):redis-py can be used together with " to discover Redis nodes. Youneed to have at least one Sentinel daemon running in order to useredis-py's Sentinel support.""Connecting redis-py to the Sentinel instance(s) is easy. You can use aSentinel connection to discover the master and slaves network addresses:"To connect to a sentinel which uses SSL ( for more examples of SSL configurations):"You can also create Redis client connections from a Sentinel instance.You can connect to either the master (for write operations) or a slave(for read-only operations).""The master and slave objects are normal Redis instances with theirconnection pool bound to the Sentinel instance. When a Sentinel backedclient attempts to establish a connection, it first queries the Sentinelservers to determine an appropriate host to connect to. If no server isfound, a MasterNotFoundError or SlaveNotFoundError is raised. Bothexceptions are subclasses of ConnectionError.""When trying to connect to a slave client, the Sentinel connection poolwill iterate over the list of slaves until it finds one that can beconnected to. If no slaves can be connected to, a connection will beestablished with the master."See " to learn more aboutRedis Sentinel.""Parser classes provide a way to control how responses from the Redisserver are parsed. redis-py ships with two parser classes, thePythonParser and the HiredisParser. By default, redis-py will attempt touse the HiredisParser if you have the hiredis module installed and willfallback to the PythonParser otherwise.""Hiredis is a C library maintained by the core Redis team. PieterNoordhuis was kind enough to create Python bindings. Using Hiredis canprovide up to a 10x speed improvement in parsing responses from theRedis server. The performance increase is most noticeable whenretrieving many pieces of data, such as from LRANGE or SMEMBERSoperations.""Hiredis is available on PyPI, and can be installed via pip just likeredis-py.""The client class uses a set of callbacks to cast Redis responses to theappropriate Python type. There are a number of these callbacks definedon the Redis client class in a dictionary called RESPONSE_CALLBACKS.""Custom callbacks can be added on a per-instance basis using theset_response_callback method. This method accepts two arguments: acommand name and the callback. Callbacks added in this manner are onlyvalid on the instance the callback is added to. If you want to define oroverride a callback globally, you should make a subclass of the Redisclient and add your callback to its RESPONSE_CALLBACKS class dictionary.""Response callbacks take at least one parameter: the response from theRedis server. Keyword arguments may also be accepted in order to furthercontrol how to interpret the response. These keyword arguments arespecified during the command's call to execute_command. The ZRANGEimplementation demonstrates the use of response callback keywordarguments with its ""withscores"" argument.""Redis client instances can safely be shared between threads. Internally,connection instances are only retrieved from the connection pool duringcommand execution, and returned to the pool directly after. Commandexecution never modifies state on the client instance.""However, there is one caveat: the Redis SELECT command. The SELECTcommand allows you to switch the database currently in use by theconnection. That database remains selected until another is selected oruntil the connection is closed. This creates an issue in thatconnections could be returned to the pool that are connected to adifferent database.""As a result, redis-py does not implement the SELECT command on clientinstances. If you use multiple Redis databases within the sameapplication, you should create a separate client instance (and possiblya separate connection pool) for each database."It is not safe to pass PubSub or Pipeline objects between threads."Pipelines are a subclass of the base Redis class that provide supportfor buffering multiple commands to the server in a single request. Theycan be used to dramatically increase the performance of groups ofcommands by reducing the number of back-and-forth TCP packets betweenthe client and server."Pipelines are quite simple to use:"For ease of use, all commands being buffered into the pipeline returnthe pipeline object itself. Therefore calls can be chained like:""In addition, pipelines can also ensure the buffered commands areexecuted atomically as a group. This happens by default. If you want todisable the atomic nature of a pipeline but still want to buffercommands, you can turn off transactions.""A common issue occurs when requiring atomic transactions but needing toretrieve values in Redis prior for use within the transaction. Forinstance, let's assume that the INCR command didn't exist and we needto build an atomic version of INCR in Python.""The completely naive implementation could GET the value, increment it inPython, and SET the new value back. However, this is not atomic becausemultiple clients could be doing this at the same time, each getting thesame value from GET.""Enter the WATCH command. WATCH provides the ability to monitor one ormore keys prior to starting a transaction. If any of those keys changeprior the execution of that transaction, the entire transaction will becanceled and a WatchError will be raised. To implement our ownclient-side INCR command, we could do something like this:""Note that, because the Pipeline must bind to a single connection for theduration of a WATCH, care must be taken to ensure that the connection isreturned to the connection pool by calling the reset() method. If thePipeline is used as a context manager (as in the example above) reset()will be called automatically. Of course you can do this the manual wayby explicitly calling reset():""A convenience method named ""transaction"" exists for handling all theboilerplate of handling and retrying watch errors. It takes a callablethat should expect a single parameter, a pipeline object, and any numberof keys to be WATCHed. Our client-side INCR command above can be writtenlike this, which is much easier to read:""Be sure to call pipe.multi() in the callable passed toRedis.transaction prior to any write commands.""redis-py includes a PubSub object that subscribes tochannels and listens for new messages. Creating a PubSubobject is easy.""Once a PubSub instance is created, channels and patternscan be subscribed to.""The PubSub instance is now subscribed to thosechannels/patterns. The subscription confirmations can be seen by readingmessages from the PubSub instance.""Every message read from a PubSub instance will be adictionary with the following keys."Let's send a message now."Unsubscribing works just like subscribing. If no arguments are passed to[p]unsubscribe, all channels or patterns will be unsubscribed from.""redis-py also allows you to register callback functions to handlepublished messages. Message handlers take a single argument, themessage, which is a dictionary just like the examples above. Tosubscribe to a channel or pattern with a message handler, pass thechannel or pattern name as a keyword argument with its value being thecallback function.""When a message is read on a channel or pattern with a message handler,the message dictionary is created and passed to the message handler. Inthis case, a None value is returned from get_message()since the message was already handled.""If your application is not interested in the (sometimes noisy)subscribe/unsubscribe confirmation messages, you can ignore them bypassing ignore_subscribe_messages=True tor.pubsub(). This will cause all subscribe/unsubscribemessages to be read, but they won't bubble up to your application."There are three different strategies for reading messages."The examples above have been using pubsub.get_message().Behind the scenes, get_message() uses the system's'select' module to quickly poll the connection's socket. If there'sdata available to be read, get_message() will read it,format the message and return it or pass it to a message handler. Ifthere's no data to be read, get_message() willimmediately return None. This makes it trivial to integrate into anexisting event loop inside your application.""Older versions of redis-py only read messages withpubsub.listen(). listen() is a generator that blocks untila message is available. If your application doesn't need to do anythingelse but receive and act on messages received from redis, listen() is aneasy way to get up an running.""The third option runs an event loop in a separate thread.pubsub.run_in_thread() creates a new thread and starts theevent loop. The thread object is returned to the caller of[un_in_thread(). The caller can use thethread.stop() method to shut down the event loop andthread. Behind the scenes, this is simply a wrapper aroundget_message() that runs in a separate thread, essentiallycreating a tiny non-blocking event loop for you.run_in_thread() takes an optional sleep_timeargument. If specified, the event loop will calltime.sleep() with the value in each iteration of the loop.""Note: Since we're running in a separate thread, there's no way tohandle messages that aren't automatically handled with registeredmessage handlers. Therefore, redis-py prevents you from callingrun_in_thread() if you're subscribed to patterns orchannels that don't have message handlers attached.""run_in_thread also supports an optional exception handler,which lets you catch exceptions that occur within the worker thread andhandle them appropriately. The exception handler will take as argumentsthe exception itself, the pubsub object, and the worker thread returnedby run_in_thread.""A PubSub object adheres to the same encoding semantics as the clientinstance it was created from. Any channel or pattern that's unicodewill be encoded using the charset specified on the clientbefore being sent to Redis. If the client'sdecode_responses flag is set the False (the default), the'channel', 'pattern' and 'data' values in message dictionarieswill be byte strings (str on Python 2, bytes on Python 3). If theclient's decode_responses is True, then the 'channel','pattern' and 'data' values will be automatically decoded to unicodestrings using the client's charset.""PubSub objects remember what channels and patterns they are subscribedto. In the event of a disconnection such as a network error or timeout,the PubSub object will re-subscribe to all prior channels and patternswhen reconnecting. Messages that were published while the client wasdisconnected cannot be delivered. When you're finished with a PubSubobject, call its .close() method to shutdown theconnection.""The PUBSUB set of subcommands CHANNELS, NUMSUB and NUMPAT are alsosupported:""redis-py includes a Monitor object that streams everycommand processed by the Redis server. Use listen() on theMonitor object to block until a command is received.""redis-py supports the EVAL, EVALSHA, and SCRIPT commands. However, thereare a number of edge cases that make these commands tedious to use inreal world scenarios. Therefore, redis-py exposes a Script object thatmakes scripting much easier to use.""To create a Script instance, use the register_scriptfunction on a client instance passing the Lua code as the firstargument. register_script returns a Script instance thatyou can use throughout your code.""The following trivial Lua script accepts two parameters: the name of akey and a multiplier value. The script fetches the value stored in thekey, multiplies it with the multiplier value and returns the result.""multiply is now a Script instance that is invoked bycalling it like a function. Script instances accept the followingoptional arguments:"Continuing the example from above:"The value of key 'foo' is set to 2. When multiply is invoked, the'foo' key is passed to the script along with the multiplier value of5. Lua executes the script and returns the result, 10.""Script instances can be executed using a different client instance, evenone that points to a completely different Redis server.""The Script object ensures that the Lua script is loaded into Redis'sscript cache. In the event of a NOSCRIPT error, it will load the scriptand retry executing it.""Script objects can also be used in pipelines. The pipeline instanceshould be passed as the client argument when calling the script. Care istaken to ensure that the script is registered in Redis's script cachejust prior to pipeline execution.""The *SCAN commands introduced in Redis 2.8 can be cumbersome to use.While these commands are fully supported, redis-py also exposes thefollowing methods that return Python iterators for convenience:scan_iter, hscan_iter,sscan_iter and zscan_iter.""redis-py is now supports cluster mode and provides a client for"."The cluster client is based on Grokzen's"", has added bugfixes, and now supersedes that library. Support for these changes is thanks tohis contributions.""Connecting redis-py to a Redis Cluster instance(s) requires at a minimum asingle node for cluster discovery. There are multiple ways in which a clusterinstance can be created:""When a RedisCluster instance is being created it first attempts to establish aconnection to one of the provided startup nodes. If none of the startup nodesare reachable, a 'RedisClusterException' will be thrown.After a connection to the one of the cluster's nodes is established, theRedisCluster instance will be initialized with 3 caches:a slots cache which maps each of the 16384 slots to the node/s handling them,a nodes cache that contains ClusterNode objects (name, host, port, redis connection)for all of the cluster's nodes, and a commands cache contains all the serversupported commands that were retrieved using the Redis 'COMMAND' output.""RedisCluster instance can be directly used to execute Redis commands. When acommand is being executed through the cluster instance, the target node(s) willbe internally determined. When using a key-based command, the target node willbe the node that holds the key's slot.Cluster management commands and other commands that are not key-based have aparameter called 'target_nodes' where you can specify which nodes to executethe command on. In the absence of target_nodes, the command will be executedon the default cluster node. As part of cluster instance initialization, thecluster's default node is randomly selected from the cluster's primaries, andwill be updated upon reinitialization. Using r.get_default_node(), you canget the cluster's default node, or you can change it using the'set_default_node' method.""The 'target_nodes' parameter is explained in the following section,'Specifying Target Nodes'.""As mentioned above, all non key-based RedisCluster commands accept the kwargparameter 'target_nodes' that specifies the node/nodes that the command shouldbe executed on.The best practice is to specify target nodes using RedisCluster class's nodeflags: PRIMARIES, REPLICAS, ALL_NODES, RANDOM. When a nodes flag is passedalong with a command, it will be internally resolved to the relevant node/s.If the nodes topology of the cluster changes during the execution of a command,the client will be able to resolve the nodes flag again with the new topologyand attempt to retry executing the command.""You could also pass ClusterNodes directly if you want to execute a command on aspecific node / node group that isn't addressed by the nodes flag. However, ifthe command execution fails due to cluster topology changes, a retry attemptwill not be made, since the passed target node/s may no longer be valid, andthe relevant cluster or connection error will be returned.""In addition, the RedisCluster instance can query the Redis instance of aspecific node and execute commands on that node directly. The Redis client,however, does not handle cluster failures and retries.""Redis supports multi-key commands in Cluster Mode, such as Set type unions orintersections, mset and mget, as long as the keys all hash to the same slot.By using RedisCluster client, you can use the known functions (e.g. mget, mset)to perform an atomic multi-key operation. However, you must ensure all keys aremapped to the same slot, otherwise a RedisClusterException will be thrown.Redis Cluster implements a concept called hash tags that can be used in orderto force certain keys to be stored in the same hash slot, see"".You can also use nonatomic for some of the multikey operations, and pass keysthat aren't mapped to the same slot. The client will then map the keys to therelevant slots, sending the commands to the slots' node owners. Non-atomicoperations batch the keys according to their hash value, and then each batch issent separately to the slot's owner.""When a ClusterPubSub instance is created without specifying a node, a singlenode will be transparently chosen for the pubsub connection on thefirst command execution. The node will be determined by:""Pattern subscribe and publish do not currently work properly due to key slots.If we hash a pattern like fo* we will receive a keyslot for that string butthere are endless possibilities for channel names based on this pattern -unknowable in advance. This feature is not disabled but the commands are notcurrently recommended for use.See ""for more.""By default, Redis Cluster always returns MOVE redirection response on accessinga replica node. You can overcome this limitation and scale read commands bytriggering READONLY mode.""To enable READONLY mode pass read_from_replicas=True to RedisClusterconstructor. When set to true, read commands will be assigned between theprimary and its replications in a Round-Robin manner.""READONLY mode can be set at runtime by calling the readonly() method withtarget_nodes='replicas', and read-write access can be restored by calling thereadwrite() method.""ClusterPipeline is a subclass of RedisCluster that provides support for Redispipelines in cluster mode.When calling the execute() command, all the commands are grouped by the nodeon which they will be executed, and are then executed by the respective nodesin parallel. The pipeline instance will wait for all the nodes to respondbefore returning the result to the caller. Command responses are returned as alist sorted in the same order in which they were sent.Pipelines can be used to dramatically increase the throughput of Redis Clusterby significantly reducing the the number of network round trips between theclient and the server."Please note:See " and""to learn more about Redis Cluster."redis-py is developed and maintained by . It can be found ", or downloaded from ".Special thanks to:descriptionThe Python interface to the Redis key-value store."""""""""" |  |   | redis-py requires a running Redis server. See " for installationinstructions.""redis-py can be installed using pip similar to otherPython packages. Do not use sudo with pip.It is usually good to work in a"" or"" to avoid conflictswith other package managers and Python projects. For a quickintroduction see "."To install redis-py, simply:"or from source:View the current documentation ."Want to contribute a feature, bug fix, or report an issue? Check outour ".redis-py supports Python 3.6+."By default, all responses are returned as bytes in Python3."If " string responses from a client should be decoded, the usercan specify "" in"". In this case, any Redis command thatreturns a string type will be decoded with the encodingspecified.""The default encoding is utf-8, but this can be customized by specifiying theencoding argument for the redis.Redis class.The encoding will be used to automatically encode anystrings passed to commands, such as key names and values.""These commands all accept a mapping of key/value pairs. In redis-py 2.Xthis mapping could be specified as *" or as ". Both ofthese styles caused issues when Redis introduced optional flags to ZADD.Relying on "" caused issues with the optional argument order,especially in Python 2.7. Relying on "" caused potentialcollision issues of user keys with the argument names in the methodsignature.""To resolve this, redis-py 3.0 has changed these three commands to allaccept a single positional argument named mapping that is expected to bea dict. For MSET and MSETNX, the dict is a mapping of key-names ->values. For ZADD, the dict is a mapping of element-names -> score.""MSET, MSETNX and ZADD now look like:""All 2.X users that use these commands must modify their code to supplykeys and values as a dict to these commands.""redis-py 2.X accidentally modified the argument order of ZINCRBY,swapping the order of value and amount. ZINCRBY now looks like:""All 2.X users that rely on ZINCRBY must swap the order of amount andvalue for the command to continue to work as intended.""redis-py 3.0 only accepts user data as bytes, strings or numbers (ints,longs and floats). Attempting to specify a key or a value as any othertype will raise a DataError exception.""redis-py 2.X attempted to coerce any type of input into a string. Whileoccasionally convenient, this caused all sorts of hidden errors whenusers passed boolean values (which were coerced to 'True' or'False'), a None value (which was coerced to 'None') or othervalues, such as user defined types.""All 2.X users should make sure that the keys and values they pass intoredis-py are either bytes, strings or numbers.""redis-py 3.0 drops support for the pipeline-based Lock and now onlysupports the Lua-based lock. In doing so, LuaLock has been renamed toLock. This also means that redis-py Lock objects require Redis server2.6 or greater."2.X users that were explicitly referring to " will have to nowrefer to " instead."redis-py 3.0 now raises a LockError when using a lock as a contextmanager and the lock cannot be acquired within the specified timeout.This is more of a bug fix than a backwards incompatible change. However,given an error is now raised where none was before, this might alarmsome users.""2.X users should make sure they're wrapping their lock code in atry/catch like this:"The "does a great job of explaining each command in detail. redis-py attemptsto adhere to the official command syntax. There are a few exceptions:"redis-py 3.0 drops support for the legacy " client class." has been renamed to " and an alias named"" is provided so that users previously using" can continue to run unchanged.The 2.X " class provided alternative implementations of a fewcommands. This confused users (rightfully so) and caused a number ofsupport issues. To make things easier going forward, it was decided todrop support for these alternate implementations and instead focus on asingle client class.""2.X users that are already using StrictRedis don't have to change theclass name. StrictRedis will continue to work for the foreseeablefuture.""2.X users that are using the Redis class will have to make changes ifthey use any of the following commands:""Behind the scenes, redis-py uses a connection pool to manage connectionsto a Redis server. By default, each Redis instance you create will inturn create its own connection pool. You can override this behavior anduse an existing connection pool by passing an already created connectionpool instance to the connection_pool argument of the Redis class. Youmay choose to do this in order to implement client side sharding or havefine-grain control of how connections are managed.""ConnectionPools manage a set of Connection instances. redis-py shipswith two types of Connections. The default, Connection, is a normal TCPsocket based connection. The UnixDomainSocketConnection allows forclients running on the same device as the server to connect via a unixdomain socket. To use a UnixDomainSocketConnection connection, simplypass the unix_socket_path argument, which is a string to the unix domainsocket file. Additionally, make sure the unixsocket parameter is definedin your redis.conf file. It's commented out by default.""You can create your own Connection subclasses as well. This may beuseful if you want to control the socket behavior within an asyncframework. To instantiate a client class using your own connection, youneed to create a connection pool, passing your class to theconnection_class argument. Other keyword parameters you pass to the poolwill be passed to the class specified during initialization.""Connections maintain an open socket to the Redis server. Sometimes thesesockets are interrupted or disconnected for a variety of reasons. Forexample, network appliances, load balancers and other services that sitbetween clients and servers are often configured to kill connectionsthat remain idle for a given threshold.""When a connection becomes disconnected, the next command issued on thatconnection will fail and redis-py will raise a ConnectionError to thecaller. This allows each application that uses redis-py to handle errorsin a way that's fitting for that specific application. However,constant error handling can be verbose and cumbersome, especially whensocket disconnections happen frequently in many production environments.""To combat this, redis-py can issue regular health checks to assess theliveliness of a connection just before issuing a command. Users can pass"" to the Redis or ConnectionPool classes or as aquery argument within a Redis URL. The value of ""must be an integer. A value of "", the default, disables health checks.Any positive integer will enable health checks. Health checks areperformed just before a command is executed if the underlying connectionhas been idle for more than "" seconds. Forexample, "" will ensure that a health check isrun on any connection that has been idle for 30 or more seconds justbefore a command is executed on that connection.""If your application is running in an environment that disconnects idleconnections after 30 seconds you should set the ""option to a value less than 30.""This option also works on any PubSub connection that is created from aclient with "" enabled. PubSub users need to ensurethat " or " are called more frequently than"" seconds. It is assumed that most workloadsalready do this."If your PubSub use case doesn't call  or "frequently, you should call "" explicitly on aregularly basis.""redis-py 3.0 changes the default value of thessl_cert_reqs option from None to'required'. See "". This changeenforces hostname validation when accepting a cert from a remote SSLterminator. If the terminator doesn't properly set the hostname on thecert this will cause redis-py 3.0 to raise a ConnectionError.""This check can be disabled by setting ssl_cert_reqs toNone. Note that doing so removes the security check. Do soat your own risk.""Example with hostname verification using a local certificate bundle(linux):""Example with hostname verification using":Example turning off hostname verification (not recommended):redis-py can be used together with " to discover Redis nodes. Youneed to have at least one Sentinel daemon running in order to useredis-py's Sentinel support.""Connecting redis-py to the Sentinel instance(s) is easy. You can use aSentinel connection to discover the master and slaves network addresses:"To connect to a sentinel which uses SSL ( for more examples of SSL configurations):"You can also create Redis client connections from a Sentinel instance.You can connect to either the master (for write operations) or a slave(for read-only operations).""The master and slave objects are normal Redis instances with theirconnection pool bound to the Sentinel instance. When a Sentinel backedclient attempts to establish a connection, it first queries the Sentinelservers to determine an appropriate host to connect to. If no server isfound, a MasterNotFoundError or SlaveNotFoundError is raised. Bothexceptions are subclasses of ConnectionError.""When trying to connect to a slave client, the Sentinel connection poolwill iterate over the list of slaves until it finds one that can beconnected to. If no slaves can be connected to, a connection will beestablished with the master."See " to learn more aboutRedis Sentinel.""Parser classes provide a way to control how responses from the Redisserver are parsed. redis-py ships with two parser classes, thePythonParser and the HiredisParser. By default, redis-py will attempt touse the HiredisParser if you have the hiredis module installed and willfallback to the PythonParser otherwise.""Hiredis is a C library maintained by the core Redis team. PieterNoordhuis was kind enough to create Python bindings. Using Hiredis canprovide up to a 10x speed improvement in parsing responses from theRedis server. The performance increase is most noticeable whenretrieving many pieces of data, such as from LRANGE or SMEMBERSoperations.""Hiredis is available on PyPI, and can be installed via pip just likeredis-py.""The client class uses a set of callbacks to cast Redis responses to theappropriate Python type. There are a number of these callbacks definedon the Redis client class in a dictionary called RESPONSE_CALLBACKS.""Custom callbacks can be added on a per-instance basis using theset_response_callback method. This method accepts two arguments: acommand name and the callback. Callbacks added in this manner are onlyvalid on the instance the callback is added to. If you want to define oroverride a callback globally, you should make a subclass of the Redisclient and add your callback to its RESPONSE_CALLBACKS class dictionary.""Response callbacks take at least one parameter: the response from theRedis server. Keyword arguments may also be accepted in order to furthercontrol how to interpret the response. These keyword arguments arespecified during the command's call to execute_command. The ZRANGEimplementation demonstrates the use of response callback keywordarguments with its ""withscores"" argument.""Redis client instances can safely be shared between threads. Internally,connection instances are only retrieved from the connection pool duringcommand execution, and returned to the pool directly after. Commandexecution never modifies state on the client instance.""However, there is one caveat: the Redis SELECT command. The SELECTcommand allows you to switch the database currently in use by theconnection. That database remains selected until another is selected oruntil the connection is closed. This creates an issue in thatconnections could be returned to the pool that are connected to adifferent database.""As a result, redis-py does not implement the SELECT command on clientinstances. If you use multiple Redis databases within the sameapplication, you should create a separate client instance (and possiblya separate connection pool) for each database."It is not safe to pass PubSub or Pipeline objects between threads."Pipelines are a subclass of the base Redis class that provide supportfor buffering multiple commands to the server in a single request. Theycan be used to dramatically increase the performance of groups ofcommands by reducing the number of back-and-forth TCP packets betweenthe client and server."Pipelines are quite simple to use:"For ease of use, all commands being buffered into the pipeline returnthe pipeline object itself. Therefore calls can be chained like:""In addition, pipelines can also ensure the buffered commands areexecuted atomically as a group. This happens by default. If you want todisable the atomic nature of a pipeline but still want to buffercommands, you can turn off transactions.""A common issue occurs when requiring atomic transactions but needing toretrieve values in Redis prior for use within the transaction. Forinstance, let's assume that the INCR command didn't exist and we needto build an atomic version of INCR in Python.""The completely naive implementation could GET the value, increment it inPython, and SET the new value back. However, this is not atomic becausemultiple clients could be doing this at the same time, each getting thesame value from GET.""Enter the WATCH command. WATCH provides the ability to monitor one ormore keys prior to starting a transaction. If any of those keys changeprior the execution of that transaction, the entire transaction will becanceled and a WatchError will be raised. To implement our ownclient-side INCR command, we could do something like this:""Note that, because the Pipeline must bind to a single connection for theduration of a WATCH, care must be taken to ensure that the connection isreturned to the connection pool by calling the reset() method. If thePipeline is used as a context manager (as in the example above) reset()will be called automatically. Of course you can do this the manual wayby explicitly calling reset():""A convenience method named ""transaction"" exists for handling all theboilerplate of handling and retrying watch errors. It takes a callablethat should expect a single parameter, a pipeline object, and any numberof keys to be WATCHed. Our client-side INCR command above can be writtenlike this, which is much easier to read:""Be sure to call pipe.multi() in the callable passed toRedis.transaction prior to any write commands.""redis-py includes a PubSub object that subscribes tochannels and listens for new messages. Creating a PubSubobject is easy.""Once a PubSub instance is created, channels and patternscan be subscribed to.""The PubSub instance is now subscribed to thosechannels/patterns. The subscription confirmations can be seen by readingmessages from the PubSub instance.""Every message read from a PubSub instance will be adictionary with the following keys."Let's send a message now."Unsubscribing works just like subscribing. If no arguments are passed to[p]unsubscribe, all channels or patterns will be unsubscribed from.""redis-py also allows you to register callback functions to handlepublished messages. Message handlers take a single argument, themessage, which is a dictionary just like the examples above. Tosubscribe to a channel or pattern with a message handler, pass thechannel or pattern name as a keyword argument with its value being thecallback function.""When a message is read on a channel or pattern with a message handler,the message dictionary is created and passed to the message handler. Inthis case, a None value is returned from get_message()since the message was already handled.""If your application is not interested in the (sometimes noisy)subscribe/unsubscribe confirmation messages, you can ignore them bypassing ignore_subscribe_messages=True tor.pubsub(). This will cause all subscribe/unsubscribemessages to be read, but they won't bubble up to your application."There are three different strategies for reading messages."The examples above have been using pubsub.get_message().Behind the scenes, get_message() uses the system's'select' module to quickly poll the connection's socket. If there'sdata available to be read, get_message() will read it,format the message and return it or pass it to a message handler. Ifthere's no data to be read, get_message() willimmediately return None. This makes it trivial to integrate into anexisting event loop inside your application.""Older versions of redis-py only read messages withpubsub.listen(). listen() is a generator that blocks untila message is available. If your application doesn't need to do anythingelse but receive and act on messages received from redis, listen() is aneasy way to get up an running.""The third option runs an event loop in a separate thread.pubsub.run_in_thread() creates a new thread and starts theevent loop. The thread object is returned to the caller of[un_in_thread(). The caller can use thethread.stop() method to shut down the event loop andthread. Behind the scenes, this is simply a wrapper aroundget_message() that runs in a separate thread, essentiallycreating a tiny non-blocking event loop for you.run_in_thread() takes an optional sleep_timeargument. If specified, the event loop will calltime.sleep() with the value in each iteration of the loop.""Note: Since we're running in a separate thread, there's no way tohandle messages that aren't automatically handled with registeredmessage handlers. Therefore, redis-py prevents you from callingrun_in_thread() if you're subscribed to patterns orchannels that don't have message handlers attached.""run_in_thread also supports an optional exception handler,which lets you catch exceptions that occur within the worker thread andhandle them appropriately. The exception handler will take as argumentsthe exception itself, the pubsub object, and the worker thread returnedby run_in_thread.""A PubSub object adheres to the same encoding semantics as the clientinstance it was created from. Any channel or pattern that's unicodewill be encoded using the charset specified on the clientbefore being sent to Redis. If the client'sdecode_responses flag is set the False (the default), the'channel', 'pattern' and 'data' values in message dictionarieswill be byte strings (str on Python 2, bytes on Python 3). If theclient's decode_responses is True, then the 'channel','pattern' and 'data' values will be automatically decoded to unicodestrings using the client's charset.""PubSub objects remember what channels and patterns they are subscribedto. In the event of a disconnection such as a network error or timeout,the PubSub object will re-subscribe to all prior channels and patternswhen reconnecting. Messages that were published while the client wasdisconnected cannot be delivered. When you're finished with a PubSubobject, call its .close() method to shutdown theconnection.""The PUBSUB set of subcommands CHANNELS, NUMSUB and NUMPAT are alsosupported:""redis-py includes a Monitor object that streams everycommand processed by the Redis server. Use listen() on theMonitor object to block until a command is received.""redis-py supports the EVAL, EVALSHA, and SCRIPT commands. However, thereare a number of edge cases that make these commands tedious to use inreal world scenarios. Therefore, redis-py exposes a Script object thatmakes scripting much easier to use.""To create a Script instance, use the register_scriptfunction on a client instance passing the Lua code as the firstargument. register_script returns a Script instance thatyou can use throughout your code.""The following trivial Lua script accepts two parameters: the name of akey and a multiplier value. The script fetches the value stored in thekey, multiplies it with the multiplier value and returns the result.""multiply is now a Script instance that is invoked bycalling it like a function. Script instances accept the followingoptional arguments:"Continuing the example from above:"The value of key 'foo' is set to 2. When multiply is invoked, the'foo' key is passed to the script along with the multiplier value of5. Lua executes the script and returns the result, 10.""Script instances can be executed using a different client instance, evenone that points to a completely different Redis server.""The Script object ensures that the Lua script is loaded into Redis'sscript cache. In the event of a NOSCRIPT error, it will load the scriptand retry executing it.""Script objects can also be used in pipelines. The pipeline instanceshould be passed as the client argument when calling the script. Care istaken to ensure that the script is registered in Redis's script cachejust prior to pipeline execution.""The *SCAN commands introduced in Redis 2.8 can be cumbersome to use.While these commands are fully supported, redis-py also exposes thefollowing methods that return Python iterators for convenience:scan_iter, hscan_iter,sscan_iter and zscan_iter.""redis-py is now supports cluster mode and provides a client for"."The cluster client is based on Grokzen's"", has added bugfixes, and now supersedes that library. Support for these changes is thanks tohis contributions.""Connecting redis-py to a Redis Cluster instance(s) requires at a minimum asingle node for cluster discovery. There are multiple ways in which a clusterinstance can be created:""When a RedisCluster instance is being created it first attempts to establish aconnection to one of the provided startup nodes. If none of the startup nodesare reachable, a 'RedisClusterException' will be thrown.After a connection to the one of the cluster's nodes is established, theRedisCluster instance will be initialized with 3 caches:a slots cache which maps each of the 16384 slots to the node/s handling them,a nodes cache that contains ClusterNode objects (name, host, port, redis connection)for all of the cluster's nodes, and a commands cache contains all the serversupported commands that were retrieved using the Redis 'COMMAND' output.""RedisCluster instance can be directly used to execute Redis commands. When acommand is being executed through the cluster instance, the target node(s) willbe internally determined. When using a key-based command, the target node willbe the node that holds the key's slot.Cluster management commands and other commands that are not key-based have aparameter called 'target_nodes' where you can specify which nodes to executethe command on. In the absence of target_nodes, the command will be executedon the default cluster node. As part of cluster instance initialization, thecluster's default node is randomly selected from the cluster's primaries, andwill be updated upon reinitialization. Using r.get_default_node(), you canget the cluster's default node, or you can change it using the'set_default_node' method.""The 'target_nodes' parameter is explained in the following section,'Specifying Target Nodes'.""As mentioned above, all non key-based RedisCluster commands accept the kwargparameter 'target_nodes' that specifies the node/nodes that the command shouldbe executed on.The best practice is to specify target nodes using RedisCluster class's nodeflags: PRIMARIES, REPLICAS, ALL_NODES, RANDOM. When a nodes flag is passedalong with a command, it will be internally resolved to the relevant node/s.If the nodes topology of the cluster changes during the execution of a command,the client will be able to resolve the nodes flag again with the new topologyand attempt to retry executing the command.""You could also pass ClusterNodes directly if you want to execute a command on aspecific node / node group that isn't addressed by the nodes flag. However, ifthe command execution fails due to cluster topology changes, a retry attemptwill not be made, since the passed target node/s may no longer be valid, andthe relevant cluster or connection error will be returned.""In addition, the RedisCluster instance can query the Redis instance of aspecific node and execute commands on that node directly. The Redis client,however, does not handle cluster failures and retries.""Redis supports multi-key commands in Cluster Mode, such as Set type unions orintersections, mset and mget, as long as the keys all hash to the same slot.By using RedisCluster client, you can use the known functions (e.g. mget, mset)to perform an atomic multi-key operation. However, you must ensure all keys aremapped to the same slot, otherwise a RedisClusterException will be thrown.Redis Cluster implements a concept called hash tags that can be used in orderto force certain keys to be stored in the same hash slot, see"".You can also use nonatomic for some of the multikey operations, and pass keysthat aren't mapped to the same slot. The client will then map the keys to therelevant slots, sending the commands to the slots' node owners. Non-atomicoperations batch the keys according to their hash value, and then each batch issent separately to the slot's owner.""When a ClusterPubSub instance is created without specifying a node, a singlenode will be transparently chosen for the pubsub connection on thefirst command execution. The node will be determined by:""Pattern subscribe and publish do not currently work properly due to key slots.If we hash a pattern like fo* we will receive a keyslot for that string butthere are endless possibilities for channel names based on this pattern -unknowable in advance. This feature is not disabled but the commands are notcurrently recommended for use.See ""for more.""By default, Redis Cluster always returns MOVE redirection response on accessinga replica node. You can overcome this limitation and scale read commands bytriggering READONLY mode.""To enable READONLY mode pass read_from_replicas=True to RedisClusterconstructor. When set to true, read commands will be assigned between theprimary and its replications in a Round-Robin manner.""READONLY mode can be set at runtime by calling the readonly() method withtarget_nodes='replicas', and read-write access can be restored by calling thereadwrite() method.""ClusterPipeline is a subclass of RedisCluster that provides support for Redispipelines in cluster mode.When calling the execute() command, all the commands are grouped by the nodeon which they will be executed, and are then executed by the respective nodesin parallel. The pipeline instance will wait for all the nodes to respondbefore returning the result to the caller. Command responses are returned as alist sorted in the same order in which they were sent.Pipelines can be used to dramatically increase the throughput of Redis Clusterby significantly reducing the the number of network round trips between theclient and the server."Please note:See " and""to learn more about Redis Cluster."redis-py is developed and maintained by . It can be found ", or downloaded from ".Special thanks to: